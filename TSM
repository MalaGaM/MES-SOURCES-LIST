#!/usr/bin/env tclsh
###############################################################################################
#
#	Name		:
#		TSM (TCL-SCRIPT-MANAGER)
#
#	Description	:
#		TSM (TCL-SCRIPT-MANAGER) is a terminal TCL script manager that allows you to easily install, update and uninstall TCL scripts.
#       It is based on a system of "source lists" containing catalogs of customizable scripts (on git), like a kind of APT for TCL Eggdrop script.
#
#		TSM (TCL-SCRIPT-MANAGER) est un gestionnaire de scripts TCL en terminal qui vous permet d'installer, de mettre à jour et de désinstaller facilement des scripts TCL.
#       Il est basé sur un système de "sources listes" contenant des catalogues de scripts (sur git) personnalisables, comme un genre de APT pour script TCL Eggdrop.
#
#	Donation	:
#		https://github.com/MalaGaM/DONATE
#
#	Website		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER
#
#	Support		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/issues
#
#	Docs		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/wiki
#
###############################################################################################
namespace eval ::TSM {
    variable ::TSM::DBSource [dict create]

    variable SCRIPTS
    array set SCRIPTS {
        NAME    "TSM"
        LNAME   "TCL-SCRIPT-MANAGER"
        VERSION "0.0.1"
    }
    set SCRIPTS(RUN_IN_PATH) [file dirname [file normalize [info script]]]
    set SCRIPTS(DB) "${SCRIPTS(RUN_IN_PATH)}/${SCRIPTS(NAME)}.db"
    variable ::TSM::CONFIG
    array set CONFIG {
        FILENAME    "TSM.cfg"
    }
    set CONFIG(PathList)    [list           \
                                [pwd]       \
                                ${SCRIPTS(RUN_IN_PATH)} \
                                [glob ~]    \
                                "/etc/tsm"  \
                                "/usr/etc"  \
                            ];

    variable ::TSM::SOURCE
    set SOURCE(PathList)    [list               \
                                [pwd]           \
                                ${SCRIPTS(RUN_IN_PATH)} \
                                [glob ~]        \
                                "/etc/tsm"      \
                                "/usr/etc/tsm" 
                            ];

}

#########
namespace eval ::TSM::FCT {
    namespace export * 
}
proc ::TSM::FCT::PKG-Load { PKG_NAME {PKG_VERS ""} } {
    if { ${PKG_VERS} == "" && [catch { package require ${PKG_NAME} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} (${ERR})" 2
    } elseif { ${PKG_VERS} != "" && [catch { package require ${PKG_NAME} ${PKG_VERS} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} ${PKG_VERS} (${ERR})" 2
    }
}
proc ::TSM::FCT::Git-Validator { GITURL BRANCH } {
    set GIT_EXEC [list git ls-remote --heads ${GITURL} ${BRANCH} | grep ${BRANCH} >/dev/null ]
    if { [catch {exec -ignorestderr -- {*}${GIT_EXEC}}] == 0} { return 1 }
    return 0
}
proc ::TSM::FCT::Git-Get-Default-Branch { GITURL } {
    if { [regexp {HEAD branch: (\w*)} [RUN-EXEC git remote show ${GITURL}] -> Branch] } {
        return ${Branch}
    }
    return -1
}
proc ::TSM::FCT::File-Read-JSon2Dict { FILENAME } {
    set FILE_DATA   [File-Read ${FILENAME}]
    if { [catch {
                    ::TSM::JSon::Valid ${FILENAME} ${FILE_DATA}
    } ERROR_MSG] } { 
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${FILE_DATA}];
}

proc ::TSM::FCT::File-Check-Permission { FILENAME {exit 0} {silent 0} } {
    if { ![file isfile ${FILENAME}] } { 
        if {  ${silent} == 0 } { ::TSM::Show::Error "'${FILENAME}' is not an file." ${exit};  }
        return 0
    } 
    if { ![file readable ${FILENAME}] } {
        if {  ${silent} == 0 } { ::TSM::Show::Error "'${FILENAME}' is not readable file. check perms" ${exit}; }
        return 0
    } 
    return 1
}

proc ::TSM::FCT::File-Write {path content {binary 0} {right "w"}} {
    set FILE_PIPE [open ${path} ${right}]
    if { ${binary} } {
        fconfigure ${FILE_PIPE} -translation binary
    }
    puts -nonewline ${FILE_PIPE} ${content}
    close ${FILE_PIPE}
}

proc ::TSM::FCT::File-Read { FILENAME } {
    set FILE_PIPE [open ${FILENAME} r]
    set FILE_DATA [read ${FILE_PIPE}]
    close ${FILE_PIPE}
    return ${FILE_DATA}
}
proc ::TSM::FCT::Get-URL-JSon2Dict { URL } {
    if { [string match https* ${URL}] } { ::http::register https 443 [list ::tls::socket -tls1 1 -autoservername 1] }
    if { [catch {set URL_TOKEN [::http::geturl ${URL} -binary 1]} ERR_MSG] } {
		return -code error "Get-URL-JSon2Dict ERROR: ${ERR_MSG} for '${URL}'."
	}
    set URL_DATA    [::http::data ${URL_TOKEN}];
    ::http::cleanup ${URL_TOKEN}
    if { [string match https* ${URL}] } { ::http::unregister https }
    if { [catch { 
                    ::TSM::JSon::Valid ${URL} ${URL_DATA}
    } ERROR_MSG] } {
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${URL_DATA}];
}
proc ::TSM::FCT::RUN-EXEC args {
    return [exec -ignorestderr -- {*}$args]
}
# Run ${code} in the directory ${path}.
proc ::TSM::FCT::RUN-IN-PATH {path code} {
    set prevPath [pwd]
    try {
        puts "Changing the current directory to '${path}'."
        cd ${path}
        uplevel 1 ${code}
    } finally {
        puts "back to the directory '${prevPath}'"
        cd ${prevPath}
    }
}
proc ::TSM::FCT::SCRIPT-GET-VALUE { SCRIPT_ID } {
    variable ::TSM::DBSource
    variable ::TSM::SCRIPTS
    set DB_DATA [::TSM::DBSource::restore ${SCRIPTS(DB)}]
    if { [string is entier ${SCRIPT_ID}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${SCRIPT_ID}] } {
        return -1
    }
    return [VALUE-GET ${DB_DATA} SCRIPTS_INDEX $SCRIPT_ID]
}
proc ::TSM::FCT::SCRIPT-GET-ID { Value } {
    variable ::TSM::DBSource
    variable ::TSM::SCRIPTS
    set DB_DATA [::TSM::DBSource::restore ${SCRIPTS(DB)}]
    set found 1
    if { [string is entier ${Value}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${Value}] } {
        return -1
    } elseif { ![string is entier ${Value}] } {
        set found 0
        dict for {id info} [VALUE-GET ${DB_DATA} SCRIPTS_INDEX] {
            dict with info {
                if { [string match -nocase ${Value} ${CODENAME}] } {
                    return ${id}
                }
            }
        }
    }
    if { ! ${found} } {
        return -1
    } else {
        return ${Value}
    }
}
proc ::TSM::FCT::VALUE-DEFAULT { Value {default NONE} } {
    return [expr { ${Value} ne "" ? ${Value} : ${default} }]
}
proc ::TSM::FCT::VALUE-DEFAULT-REVERSE { Value {default NONE} } {
    if { [llength ${Value}] == 0 } { return ${default} }
}
proc ::TSM::FCT::VALUE-GET { DB key {subkey ""} {default NONE}} {
    if { [dict exists ${DB} ${key}] } {
        if { ${subkey} == "" } {
            return [dict get ${DB} ${key}];
        }
        set SUBLIST [dict get ${DB} ${key}];
        if {[dict exists ${SUBLIST} ${subkey}]} {
            return [dict get ${SUBLIST} ${subkey}];
        } elseif {${default} ne {NONE}} {
            return ${default}
        } else {
            error [list no subkey ${subkey} for ${key} in config];
        }
    } elseif { ${default} ne {NONE} } {
        return ${default}
    } else {
        error [list no key ${key} in config];
    }
}
proc ::TSM::FCT::TEXT-SPACE-SEP { text length } {
	set text			[string trim $text]
    set text_length		[string length $text]
    if { [expr {$text_length % 2}] } { 
        set text_length		[expr [string length $text]+1]
        set text            "$text "
    }
	
	# si le $text est plus grand que $length on le retourne on le coupe avec deux points
	if { $text_length > $length } { set text "[string range $text 0 [expr $length-3]].." }
	# si le text a une longueur impair, on rajoute un space derriere
	if { [expr {($text_length % 2) != 0}] } { set text " $text" }
	
	set espace_length	[expr ($length - $text_length)/2]
	set espace			[string repeat " " $espace_length]; 
	return $espace$text$espace 
}

proc ::TSM::FCT::CONFIG-GET { key {subkey ""} {default NONE} } {
    variable ::TSM::CONFIG
    return [VALUE-GET ${CONFIG(DATA)} $key $subkey $default]
}

#########
namespace eval ::TSM::Show {

}
proc ::TSM::Show::Banner {} {
    puts "  _____ ___ __  __ \n |_   _/ __|  \\/  |\n   | | \\__ \\ |\\/| |\n   |_| |___/_|  |_|\n-TCL-SCRIPT-MANAGER-"
}
proc ::TSM::Show::Informations {} {
    variable ::TSM::SOURCE
    puts "Eggdrop    : ${::TSM::EGGDROP_VERSION} (${::TSM::INSTALLDIR})"
    puts "TCL        : ${::TSM::TCL_VERSION}"
    #puts "SCRIPTS DB : ${SOURCE(SCRIPT_NUMBER)}"
    puts "--------------------"
}
proc ::TSM::Show::Help {} {
    puts "This script expects a parameter. Use:"
    ::TSM::COMMANDS::Help::UpdateDB
    ::TSM::COMMANDS::Help::List
    ::TSM::COMMANDS::Help::Search
    ::TSM::COMMANDS::Help::Show
    ::TSM::COMMANDS::Help::Install
    ::TSM::COMMANDS::Help::GenDateNow
    ::TSM::COMMANDS::Help::Main
}
proc ::TSM::Show::Error { ERR_MSG {exit 0} } {
    puts "ERROR: ${ERR_MSG}"
    if { ${exit} != 0 } { exit ${exit} }
    return ${exit}
 
}
#########
namespace eval ::TSM::Source {}
proc ::TSM::Source::Get:FILENAME:Path {} {
    variable ::TSM::SOURCE
    variable ::TSM::CONFIG
    namespace import -force ::TSM::FCT::*
    # Chargement en cascade
    set SOURCE_LIST [list]
    foreach SOURCE_PATH ${SOURCE(PathList)} {
        set SOURCE_PATH [file normalize ${SOURCE_PATH}]
        if { [file exists "${SOURCE_PATH}/sources.list"] && [File-Check-Permission "${SOURCE_PATH}/sources.list" 0 1] } {
            lappend SOURCE_LIST "${SOURCE_PATH}/sources.list"
        }
        if { [file isdirectory "${SOURCE_PATH}/sources.list.d"] } {
            foreach SOURCE_PATH_DIR "${SOURCE_PATH}/sources.list.d" { 
                foreach SOURCE_PATH_LIST [glob -nocomplain -directory ${SOURCE_PATH_DIR} *.list] { 
                    if { [file exists ${SOURCE_PATH_LIST}] } { lappend SOURCE_LIST ${SOURCE_PATH_LIST} }
                }
            }
        }
    }
    
    foreach SOURCE_FILE [CONFIG-GET sources] {
        if { [string match http* ${SOURCE_FILE}] } {
            lappend SOURCE_LIST ${SOURCE_FILE}
        } elseif { [file exists ${SOURCE_FILE}] && [File-Check-Permission "${SOURCE_PATH}/sources.list" 0 1] } {
            lappend SOURCE_LIST [file normalize ${SOURCE_FILE}]
        } 
    }
    set SOURCE(LIST) [lsort -unique ${SOURCE_LIST}]
}
#########
namespace eval ::TSM::List {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::List::Validator { SOURCE_LIST_DATA SOURCE_URI } {
    if { ![dict exists ${SOURCE_LIST_DATA} list] } { 
        ::TSM::Show::Error "Bad Source List file : No 'list' information in ${SOURCE_URI}" 0
        return 0
    }
    if { ![dict exists ${SOURCE_LIST_DATA} scripts] } { 
        ::TSM::Show::Error "Bad Source List file : No 'scripts' information in ${SOURCE_URI}" 0
        return 0
    }
    return 1
}
proc ::TSM::List::Get:Informations { LIST_DATA SOURCE_URI } {
    variable ::TSM::SOURCE
    variable ::TSM::DBSource
    set LIST_NAME       ""
    set LIST_CONTACT    ""
    set LIST_DATE       ""
    set SCRIPTS_CNT     0
    puts "Please be patient, it may take a while ..."
    if { [dict exists ${LIST_DATA} scripts] && [VALUE-GET ${LIST_DATA} scripts] == "" } { ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: No scripts informations found in ${SOURCE_URI}. skipped!"; return 0 }
    if { [dict exists ${LIST_DATA} list] } { 
        set list    [VALUE-GET ${LIST_DATA} list]
        if { [dict exists ${list} name] }       { 
            set LIST_NAME [VALUE-GET ${list} name] 
            if { [::TSM::DBSource::exists ${LIST_NAME}] } {
                ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: Duplicata source '${SOURCE_URI}' with '[::TSM::DBSource::get_data ${LIST_NAME} source]', skipped!"; return 0
            }
        }
        if { [dict exists ${list} contact] }    { set LIST_CONTACT [VALUE-GET ${list} contact] }
        if { [dict exists ${list} updateat] }   { set LIST_DATE [VALUE-GET ${list} updateat] }
        
            dict set DBSource ${LIST_NAME} updateat ${LIST_DATE}
            dict set DBSource ${LIST_NAME} contact ${LIST_CONTACT}
            dict set DBSource ${LIST_NAME} source ${SOURCE_URI}
    } else { ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: No List informations found in ${SOURCE_URI}"; return 0 }
    if { [dict exists ${LIST_DATA} scripts] } { 
        set SCRIPTS_LIST            [VALUE-GET ${LIST_DATA} scripts]
        foreach SCRIPT_DATA ${SCRIPTS_LIST} { 
            set SCRIPT_NAME             ""
            set SCRIPT_CATEGORY         ""
            set SCRIPT_DESCRIPTION      ""
            set SCRIPT_VERSION          ""
            set SCRIPT_AUTHOR           ""
            set SCRIPT_GITURL           ""
            set SCRIPT_GITREVISION      ""
            set SCRIPT_DOCS             NONE
            set SCRIPT_TROUBLESHOOTING  NONE
            set SCRIPT_MIN_VERS_EGG     NONE
            set SCRIPT_MIN_VERS_TCL     NONE
            set SCRIPT_PKG_REQUIRE      NONE
            set SCRIPT_POST_INSTALL     NONE
            if { [dict exists ${SCRIPT_DATA} name] }                { set SCRIPT_NAME               [VALUE-GET ${SCRIPT_DATA} name] }
            if { ${SCRIPT_NAME} == "" } { continue }
            if { [dict exists ${SCRIPT_DATA} category] }            { set SCRIPT_CATEGORY           [VALUE-GET ${SCRIPT_DATA} category] }
            if { [dict exists ${SCRIPT_DATA} description] }         { set SCRIPT_DESCRIPTION        [VALUE-GET ${SCRIPT_DATA} description] }
            if { [dict exists ${SCRIPT_DATA} version] }             { set SCRIPT_VERSION            [VALUE-GET ${SCRIPT_DATA} version] }
            if { [dict exists ${SCRIPT_DATA} author] }              { set SCRIPT_AUTHOR             [VALUE-GET ${SCRIPT_DATA} author] }
            if { [dict exists ${SCRIPT_DATA} documentation] }       { set SCRIPT_DOCS               [VALUE-GET ${SCRIPT_DATA} documentation] }
            if { [dict exists ${SCRIPT_DATA} giturl] }              { set SCRIPT_GITURL             [VALUE-GET ${SCRIPT_DATA} giturl] }
            if { [dict exists ${SCRIPT_DATA} gitrevision] }         { set SCRIPT_GITREVISION        [VALUE-GET ${SCRIPT_DATA} gitrevision] }
            if { [dict exists ${SCRIPT_DATA} troubleshooting] }     { set SCRIPT_TROUBLESHOOTING    [VALUE-GET ${SCRIPT_DATA} troubleshooting] }
            if { [dict exists ${SCRIPT_DATA} mineggdropversion] }   { set SCRIPT_MIN_VERS_EGG       [VALUE-GET ${SCRIPT_DATA} mineggdropversion] }
            if { [dict exists ${SCRIPT_DATA} mintclversion] }       { set SCRIPT_MIN_VERS_TCL       [VALUE-GET ${SCRIPT_DATA} mintclversion] }
            if { [dict exists ${SCRIPT_DATA} packagesrequire] }     { set SCRIPT_PKG_REQUIRE        [VALUE-GET ${SCRIPT_DATA} packagesrequire] }
            if { [dict exists ${SCRIPT_DATA} postinstalltext] }     { set SCRIPT_POST_INSTALL       [VALUE-GET ${SCRIPT_DATA} postinstalltext] }

            # Control GIT VALIDE
            if { [::TSM::FCT::Git-Validator ${SCRIPT_GITURL} ${SCRIPT_GITREVISION}] != 1 } {
                puts "ERROR: Source list '${LIST_NAME}' have bad source URI/REVISION for '${SCRIPT_NAME}' ( ${SCRIPT_GITURL} / ${SCRIPT_GITREVISION} ) "
                continue

            }
            incr SOURCE(SCRIPT_NUMBER)
            incr SCRIPTS_CNT
            #
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCENAME ${LIST_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCEDATE ${LIST_DATE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCECONTACT ${LIST_CONTACT}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODENAME ${SCRIPT_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODEVERS ${SCRIPT_VERSION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CATEGORY ${SCRIPT_CATEGORY}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DESCRIPTION ${SCRIPT_DESCRIPTION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} AUTHOR ${SCRIPT_AUTHOR}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DOCS ${SCRIPT_DOCS}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} GITURL ${SCRIPT_GITURL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} GITREVISION ${SCRIPT_GITREVISION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} TROUBLESHOOTING ${SCRIPT_TROUBLESHOOTING}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_EGG ${SCRIPT_MIN_VERS_EGG}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_TCL ${SCRIPT_MIN_VERS_TCL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} PKG_REQUIRE ${SCRIPT_PKG_REQUIRE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} POST_INSTALL ${SCRIPT_POST_INSTALL}
        }
    }
    dict set DBSource ${LIST_NAME} SCRIPTS_CNT ${SCRIPTS_CNT}
    puts [format "Informations list: '%s' by '%s' with '%s' scripts Last update: '%s'" ${LIST_NAME} ${LIST_CONTACT} ${SCRIPTS_CNT} ${LIST_DATE}]
    return 1
}
#########
namespace eval ::TSM::JSon {}
proc ::TSM::JSon::Valid { FILENAME JSON_DATA } {
    if { ![::json::validate ${JSON_DATA}] || [llength ${JSON_DATA}] == 0} {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an JSON FILE!"
    }
    if { [catch { ::json::json2dict ${JSON_DATA} } ERR_MSG] } {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an correct format JSON FILE! (JSON ERROR FORMAT)"
  }
    return 1
}
#########
    # https://boulets.eggdrop.fr/tcl/routines/tcl-toolbox-0033.html
namespace eval ::TSM::DBSource {
    namespace import -force ::TSM::FCT::*
}

###############################################################################
### Supprime une catégorie et ses sous-catégories dans la base de données.
###############################################################################
proc ::TSM::DBSource::delete_entry {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } elseif { ![::tcl::dict::exists ${DBSource} {*}${args}] } {
        return -code error "entrée inexistante"
    } else {
        if { [catch { ::tcl::dict::unset DBSource {*}${args} }] } {
            return -code error "entrée inexistante"
        }
    }
}
###############################################################################
### Affiche les entrées que contiennent une catégorie dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_entries {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error  "base de données vide"
    } else {
        if { [catch { ::tcl::dict::keys [::tcl::dict::get ${DBSource} {*}${args}] } result ] } {
            return -code error "catégorie inexistante"
        } else {
            return ${result}
        }
    }
}
###############################################################################
### Affiche la valeur d'une entrée dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_data {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } else {
        if { [catch { ::tcl::dict::get ${DBSource} {*}${args} } result] } {
            return -code error "catégorie inexistante"
        } else {
            return ${result}
        }
    }
}
proc ::TSM::DBSource::exists {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return 0
    } else {
        if { [catch { ::tcl::dict::get ${DBSource} {*}${args} } result] } {
            return 0
        } else {
            return 1
        }
    }
}
proc ::TSM::DBSource::save { DB_FILE } {
    variable ::TSM::DBSource
    set FILE_PIPE       [open ${DB_FILE} w];
    fconfigure ${FILE_PIPE} -translation binary;
    puts -nonewline ${FILE_PIPE} ${DBSource}
    close ${FILE_PIPE}
}
proc ::TSM::DBSource::restore { DB_FILE } {
    variable ::TSM::DBSource
    set FILE_PIPE   [open ${DB_FILE} r];
    set FILE_DATA   [gets ${FILE_PIPE}];
    set DBSource    [dict get ${FILE_DATA}]
    
    close ${FILE_PIPE}
    return ${DBSource}
}
###############################################################################
### Incrémente une entrée numérique dans la base de données.
### L'incrément peut être une valeur négative et/ou décimale.
###############################################################################
proc ::TSM::DBSource::incr_value {args} {
    if { ![::tcl::string::is double [set increment [lindex ${args} end]]] } {
        return -code error "l'incrément doit être numérique"
    } else {
        set args [lreplace ${args} end end]
        variable ::TSM::DBSource
        if { ![::tcl::info::exists DBSource] } {
            return -code error "base de données vide"
        } else {
            if { ![::tcl::dict::exists ${DBSource} {*}${args}] } {
                return -code error "entrée inexistante"
            } elseif { ![::tcl::string::is double [::tcl::dict::get ${DBSource} {*}${args}]] } {
                return -code error "la valeur de cette entrée n'est pas numérique"
            } elseif { [catch { ::tcl::dict::set DBSource {*}${args} [expr {[::tcl::dict::get ${DBSource} {*}${args}] + ${increment}}] } result] } {
                return -code error "catégorie inexistante"
            } else {
                return ${result}
            }
        }
    }
}
#########
namespace eval ::TSM::Config {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::Config::Locate:FILENAME {} {
    variable ::TSM::CONFIG
    # Chargement unique (non en cascade)
    foreach CONFIG_PATH ${CONFIG(PathList)} {
        if { [file exists "${CONFIG_PATH}/${CONFIG(FILENAME)}"] } { return "${CONFIG_PATH}/${CONFIG(FILENAME)}" }
    }
    return -code error "Config file '${CONFIG(FILENAME)}' not found. Rename 'TSM.example.cfg' to '${CONFIG(FILENAME)}' and edit it!"
}
proc ::TSM::Config::Check {} {
    variable ::TSM::CONFIG
    variable ::TSM::SOURCE
    ### sources
    if { ![dict exists ${CONFIG(DATA)} sources] } {  
        ::TSM::Show::Error "No sources list in '${CONFIG(FILENAME)}' file." 2;
    }
    ### eggdrop
    if { ![dict exists ${CONFIG(DATA)} eggdrop] } { 
        ::TSM::Show::Error "No key 'eggdrop' in '${CONFIG(FILENAME)}' file." 2;
    } else {
        ## eggdrop binary
        if { ![dict exists ${CONFIG(DATA)} eggdrop binary] } { 
            ::TSM::Show::Error "No value 'binary' for key 'eggdrop' in '${CONFIG(FILENAME)}' file." 2;
        } else {
            set eggdrop_path [file normalize [CONFIG-GET eggdrop binary]]
            if { ![file executable ${eggdrop_path}] } { ::TSM::Show::Error "Value 'binary' for key 'eggdrop' in '${CONFIG(FILENAME)}' is not executable (${eggdrop_path}) file." 2; }
            set ::TSM::EGGDROP_VERSION  [lindex [RUN-EXEC strings ${eggdrop_path} | grep EGG_STRINGVER] 1]
            set ::TSM::TCL_VERSION      [lindex [RUN-EXEC strings ${eggdrop_path} | grep TCL_VERSION] 1]
        }
        ## eggdrop installdir
        if { ![dict exists ${CONFIG(DATA)} eggdrop installdir] } { 
            ::TSM::Show::Error "No value 'installdir' for key 'eggdrop' in '${CONFIG(FILENAME)}' file." 2;
        } else {
            set ::TSM::INSTALLDIR [file normalize [CONFIG-GET eggdrop installdir]]
            if { ![file isdirectory ${::TSM::INSTALLDIR}] } { ::TSM::Show::Error "Value 'installdir' for key 'eggdrop' in '${CONFIG(FILENAME)}' is not an directory (${::TSM::INSTALLDIR}) file." 2; }
        }
    }
    ### list
    if { ![dict exists ${CONFIG(DATA)} list] } { 
        ::TSM::Show::Error "No key 'list' in '${CONFIG(FILENAME)}' file." 2;
    } else {
        ## list limit
        if { ![dict exists ${CONFIG(DATA)} list limit] } { 
            ::TSM::Show::Error "No value 'limit' for key 'list' in '${CONFIG(FILENAME)}' file." 2;
        }
    }
    ### search
    if { ![dict exists ${CONFIG(DATA)} search] } { 
        ::TSM::Show::Error "No key 'search' in '${CONFIG(FILENAME)}' file." 2;
    } else {
        ## search limit
        if { ![dict exists ${CONFIG(DATA)} search limit] } { 
            ::TSM::Show::Error "No value 'limit' for key 'search' in '${CONFIG(FILENAME)}' file." 2;
        }
    }
}
proc ::TSM::Config::Load {} {
    variable ::TSM::CONFIG
    if { [ catch {
        set CONFIG(FilePath) [::TSM::Config::Locate:FILENAME]
    } ERROR_MSG ] } {
        puts "ERROR: ${ERROR_MSG}"
        return 
    }
    puts [format "Reading Config file from '%s'..." ${CONFIG(FilePath)}]
    File-Check-Permission ${CONFIG(FilePath)}
    set CONFIG(DATA) [File-Read-JSon2Dict ${CONFIG(FilePath)}]
}
#########
namespace eval ::TSM::COMMANDS {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::COMMANDS::UpdateDB {} {
    variable ::TSM::SOURCE
    variable ::TSM::SCRIPTS
    ::TSM::Source::Get:FILENAME:Path
    set SOURCE(SCRIPT_NUMBER)   0
    set SOURCE(LIST_NUMBER)     0
    foreach SOURCE_URI ${SOURCE(LIST)} {
        if { [string match http* ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA [Get-URL-JSon2Dict ${SOURCE_URI}]
            puts [format "Reading Source file from '%s'..." ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ![::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            incr SOURCE(LIST_NUMBER)
        } elseif { [File-Check-Permission ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA    [File-Read-JSon2Dict ${SOURCE_URI}]
            puts [format "Reading Source file from '%s'..." ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ! [::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            incr SOURCE(LIST_NUMBER)
        } else {
            ::TSM::Show::Error "::TSM::COMMANDS::UpdateDB ERROR: The file '${SOURCE_URI}' can't read!" 0
            continue
        }
    }
    puts "--------------------"
    puts "Total lists '${SOURCE(LIST_NUMBER)}' withs scripts: '${SOURCE(SCRIPT_NUMBER)}'"
    ::TSM::DBSource::save ${SCRIPTS(DB)}
}
proc ::TSM::COMMANDS::GenDateNow {} {
    puts "[clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S %Z" -gmt 1]"
}
proc ::TSM::COMMANDS::List { SEARCH_TEXT } {
    variable ::TSM::DBSource
    variable ::TSM::CMDLINE
    variable ::TSM::SCRIPTS
    try {
        array set params [::cmdline::getoptions SEARCH_TEXT ${CMDLINE(list_options)} ${CMDLINE(list_usage)}]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA [::TSM::DBSource::restore ${SCRIPTS(DB)}]
    set found 0
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    puts "|   ID   |      Name      |     version      |    Category    |                    Descripstion                    |         Repo         |"
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    dict for {id info} [VALUE-GET ${DB_DATA} SCRIPTS_INDEX] {
        dict with info {
            if { 
                [string match -nocase "*${SEARCH_TEXT}*" ${CODENAME}] \
                && ( [string match -nocase "all" ${params(c)}] || [string match -nocase ${params(c)} ${CATEGORY} ] )
            } {
                if { ${found} >= ${params(l)} } { break }
                set MSG     "| [TEXT-SPACE-SEP ${id} 6] "
                append MSG  "| [TEXT-SPACE-SEP ${CODENAME} 14] "
                append MSG  "| [TEXT-SPACE-SEP ${CODEVERS} 16] "
                append MSG  "| [TEXT-SPACE-SEP ${CATEGORY} 14] "
                append MSG  "| [TEXT-SPACE-SEP ${DESCRIPTION} 50] "
                append MSG  "| [TEXT-SPACE-SEP ${SOURCENAME} 20] |"
                puts ${MSG}
                incr found
            }
            
        }

    }
    if { $found == 0 } { 
        puts "|    -   |       -        |        -         |       ALL      |                Nohting found ...                   |          ALL         |"
    }
    puts "*--------*----------------*------------------*----------------*---------------------------*------------------------*----------------------*"
    puts "| [TEXT-SPACE-SEP "Help: ${::argv0} List -help" 42] | [TEXT-SPACE-SEP "Category: ${params(c)}" 42] | [TEXT-SPACE-SEP "Limit: ${params(l)}" 44]  |"
    puts "*--------------------------------------------*--------------------------------------------*-----------------------------------------------*"
    puts "* For more information on a script: ${::argv0} show <ID|Name>"
}
proc ::TSM::COMMANDS::Search { SEARCH_TEXT } {
    variable ::TSM::DBSource
    variable ::TSM::CMDLINE
    variable ::TSM::SCRIPTS
    try {
        array set params [::cmdline::getoptions SEARCH_TEXT ${CMDLINE(search_options)} ${CMDLINE(search_usage)}]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA [::TSM::DBSource::restore ${SCRIPTS(DB)}]
    set found 0
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    puts "|   ID   |      Name      |     version      |    Category    |                    Descripstion                    |         Repo         |"
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    dict for {id info} [VALUE-GET ${DB_DATA} SCRIPTS_INDEX] {
        dict with info {
            if { 
                [string match -nocase "*${SEARCH_TEXT}*" ${DESCRIPTION}] \
                && ( [string match -nocase "all" ${params(c)}] || [string match -nocase ${params(c)} ${CATEGORY} ] )
            } {
                if { ${found} >= ${params(l)} } { break }
                set MSG     "| [TEXT-SPACE-SEP ${id} 6] "
                append MSG  "| [TEXT-SPACE-SEP ${CODENAME} 14] "
                append MSG  "| [TEXT-SPACE-SEP ${CODEVERS} 16] "
                append MSG  "| [TEXT-SPACE-SEP ${CATEGORY} 14] "
                append MSG  "| [TEXT-SPACE-SEP ${DESCRIPTION} 50] "
                append MSG  "| [TEXT-SPACE-SEP ${SOURCENAME} 20] |"
                puts ${MSG}
                incr found
            }
        }
    }
    if { $found == 0 } { 
        puts "|    -   |       -        |        -         |       ALL      |                Nohting found ...                   |          ALL         |"
    }
    puts "*--------*----------------*------------------*----------------*---------------------------*------------------------*----------------------*"
    puts "| [TEXT-SPACE-SEP "Help: ${::argv0} List -help" 42] | [TEXT-SPACE-SEP "Category: ${params(c)}" 42] | [TEXT-SPACE-SEP "Limit: ${params(l)}" 44]  |"
    puts "*--------------------------------------------*--------------------------------------------*-----------------------------------------------*"
    puts "* For more information on a script: ${::argv0} show <ID|Name>"
}
proc ::TSM::COMMANDS::Install { args } {
    variable ::TSM::CMDLINE
    variable ::TSM::CONFIG
    variable ::TSM::SCRIPTS
    try {
        array set params [::cmdline::getoptions args ${CMDLINE(install_options)} ${CMDLINE(install_usage)}]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA         [::TSM::DBSource::restore ${SCRIPTS(DB)}]
    set SCRIPT_ID       [SCRIPT-GET-ID ${args}]
    set SCRIPT_DATA     [SCRIPT-GET-VALUE ${SCRIPT_ID}]
    set SCRIPT_NAME     [VALUE-GET ${SCRIPT_DATA} CODENAME]
    set SCRIPT_VERS     [VALUE-GET ${SCRIPT_DATA} CODEVERS]
    set SCRIPT_GITURL   [VALUE-GET ${SCRIPT_DATA} GITURL]
    set INSTALLDIR      [file normalize [CONFIG-GET eggdrop installdir]]
    if { ! [file exists ${INSTALLDIR}] } {
        puts "The directory '${INSTALLDIR}' don't exist! : Create the directory or change the INSTALLDIR in ${CONFIG(FILENAME)}";
        exit 2
    }
    RUN-IN-PATH ${INSTALLDIR} {
        if { [file isdirectory ${SCRIPT_NAME}] } {
            puts "The directory '${INSTALLDIR}/${SCRIPT_NAME}' already exists!"
            puts "Remove it or use ${::argv0} update ${SCRIPT_NAME} !";
            exit 2
        }
        puts "Get script source from '${SCRIPT_GITURL}' into '${INSTALLDIR}/${SCRIPT_NAME}'."
        RUN-EXEC git clone ${SCRIPT_GITURL} ${SCRIPT_NAME}
        RUN-IN-PATH ${SCRIPT_NAME} {
            RUN-EXEC git fetch ${SCRIPT_GITURL} [VALUE-GET ${SCRIPT_DATA} GITREVISION]
            RUN-EXEC git checkout [VALUE-GET ${SCRIPT_DATA} GITREVISION]
            set commit [RUN-EXEC git rev-parse HEAD]
            File-Write git-commit ${commit}
        }
        File-Write .TSM "${SCRIPT_NAME} ${commit}"

    }
    puts "Commit: $commit"
    File-Write "${SCRIPTS(RUN_IN_PATH)}/.TSM" "${SCRIPT_NAME} ${commit} ${SCRIPT_VERS} ${INSTALLDIR}/${SCRIPT_NAME}"

}    
proc ::TSM::COMMANDS::Show { STR_SEARCH } {
    variable ::TSM::DBSource
    variable ::TSM::SCRIPTS
    set DB_DATA [::TSM::DBSource::restore ${SCRIPTS(DB)}]
    set found 1
    if { [string is entier ${STR_SEARCH}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${STR_SEARCH}] } {
        ::TSM::Show::Error "${::argv0} Show: script ID '${STR_SEARCH}' no found" 2
    } elseif { ![string is entier ${STR_SEARCH}] } {
        set found 0
        dict for {id info} [VALUE-GET ${DB_DATA} SCRIPTS_INDEX] {
            dict with info {
                if { [string match -nocase ${STR_SEARCH} ${CODENAME}] } {
                    set STR_SEARCH ${id}
                    set found 1
                    break
                }
            }
        }
    }
    if { ! ${found} } {
        ::TSM::Show::Error "${::argv0} Show: script Name '${STR_SEARCH}' no found" 2
    }
    set SCRIPT_DATA [VALUE-GET ${DB_DATA} SCRIPTS_INDEX ${STR_SEARCH}]
    dict with SCRIPT_DATA {
        puts ""
        puts "****** SOURCE INFORMATIONS ******"
        puts ""
        puts "[TEXT-SPACE-SEP "NAME" 30]: [VALUE-DEFAULT ${SOURCENAME}]"
        puts "[TEXT-SPACE-SEP "DATE" 30]: [VALUE-DEFAULT ${SOURCEDATE}]"
        puts "[TEXT-SPACE-SEP "CONTACT" 30]: [VALUE-DEFAULT ${SOURCECONTACT}]"
        puts ""
        puts "****** SCRIPT INFORMATIONS ******"
        puts ""
        puts "[TEXT-SPACE-SEP "ID" 30]: [VALUE-DEFAULT ${STR_SEARCH}]"
        puts "[TEXT-SPACE-SEP "NAME" 30]: [VALUE-DEFAULT ${CODENAME}]"
        puts "[TEXT-SPACE-SEP "VERSION" 30]: [VALUE-DEFAULT ${CODEVERS}]"
        puts "[TEXT-SPACE-SEP "CATEGORY" 30]: [VALUE-DEFAULT ${CATEGORY}]"
        puts "[TEXT-SPACE-SEP "DESCRIPTION" 30]: [VALUE-DEFAULT ${DESCRIPTION}]"
        puts "[TEXT-SPACE-SEP "AUTHOR" 30]: [VALUE-DEFAULT ${AUTHOR}]"
        puts "[TEXT-SPACE-SEP "GIT URL" 30]: [VALUE-DEFAULT ${GITURL}]"
        puts "[TEXT-SPACE-SEP "GIT REVISION" 30]: [VALUE-DEFAULT ${GITREVISION}]"
        puts "[TEXT-SPACE-SEP "TROUBLESHOOTING" 30]: [VALUE-DEFAULT ${TROUBLESHOOTING}]"
        puts "[TEXT-SPACE-SEP "Minimum version for Eggdrop" 30]: [VALUE-DEFAULT ${MIN_VERS_EGG}]"
        puts "[TEXT-SPACE-SEP "Minimum version for TCL" 30]: [VALUE-DEFAULT ${MIN_VERS_TCL}]"
        puts ""
        puts "****** Packages Required ******"
        puts "[VALUE-DEFAULT-REVERSE ${PKG_REQUIRE}]"
        
        dict for {PKG_NAME PKG_VERS} ${PKG_REQUIRE} {
            puts "[TEXT-SPACE-SEP "${PKG_NAME}" 30]: [VALUE-DEFAULT ${PKG_VERS}]"
        }
        puts ""
        puts "****** post-installation INFORMATIONS ******"
        puts "[VALUE-DEFAULT-REVERSE ${POST_INSTALL}]"
        foreach {INSTALL_TEXT} ${POST_INSTALL} {
            puts "      ${INSTALL_TEXT}"
        }
        puts ""
        puts "*********************************"
    }
}
#########
namespace eval ::TSM::COMMANDS::Help {}
proc ::TSM::COMMANDS::Help { args } {
    set COMMANDS    [lindex ${args} 0]
    set SUBCOMMANDS [lrange ${args} 1 end]
    switch -nocase ${COMMANDS} {
        UpdateDB  {
            ::TSM::COMMANDS::Help::UpdateDB 1
        }
        List  {
            ::TSM::COMMANDS::Help::List 1
        }
        Search  {
            ::TSM::COMMANDS::Help::Search 1
        }
        GenDateNow  {
            ::TSM::COMMANDS::Help::GenDateNow 1
        }
        Install  {
            ::TSM::COMMANDS::Help::Install 1
        }
        Show  {
            ::TSM::COMMANDS::Help::Show 1
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::COMMANDS::Help::UpdateDB    { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} UpdateDB               - Update database list of available scripts"
}
proc ::TSM::COMMANDS::Help::Search    { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Search <search_string> - Search in scripts descriptions"
    if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(search_options)} ${::TSM::CMDLINE(search_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::List        { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} List   <search_string> - List scripts based on script names"
    if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(list_options)} ${::TSM::CMDLINE(list_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::Main  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} help       <parameter> - Show help for <parameter>"
}
proc ::TSM::COMMANDS::Help::Install  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Install     <Num|Name> - Install script"
       if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(install_options)} ${::TSM::CMDLINE(install_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::GenDateNow  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} GenDateNow             - Generator date now with format '%a, %d %b %Y %H:%M:%S %Z'"
}
proc ::TSM::COMMANDS::Help::Show        { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Show        <Num|Name> - Show script details"
}
#########

proc ::TSM::main { } {
    variable ::TSM::SOURCE
    ::TSM::Init
    set COMMANDS    [lindex ${::argv} 0]
    set SUBCOMMANDS [lrange ${::argv} 1 end]
    switch -nocase ${COMMANDS} {
        UpdateDB  {
            ::TSM::COMMANDS::UpdateDB
        }
        List  {
            ::TSM::COMMANDS::List ${SUBCOMMANDS}
        }
        GenDateNow  {
            ::TSM::COMMANDS::GenDateNow
        }
        Show  {
            ::TSM::COMMANDS::Show ${SUBCOMMANDS}
        }
        Search  {
            ::TSM::COMMANDS::Search ${SUBCOMMANDS}
        }
        Install  {
            ::TSM::COMMANDS::Install ${SUBCOMMANDS}
        }
        Help  {
            ::TSM::COMMANDS::Help ${SUBCOMMANDS}
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::Init {} {
    namespace import -force ::TSM::FCT::*
    PKG-Load Tcl 8.5
    PKG-Load json
    PKG-Load http
    PKG-Load tls
    PKG-Load cmdline 1.5
    
    ::TSM::Config::Load
    ::TSM::Config::Check
    ::TSM::Show::Banner
    ::TSM::Show::Informations

    variable ::TSM::CMDLINE
    set CMDLINE(list_options)       [list  \
                                        [list l.arg [CONFIG-GET list limit]     "set the limit to show"]    \
                                        [list c.arg "all"                       "set category to find"]     \
                                    ]
    set CMDLINE(list_usage)         "List \[options] <search_string> ...\noptions:"

    set CMDLINE(search_options)     [list  \
                                        [list l.arg [CONFIG-GET search limit]   "set the limit to show"]    \
                                        [list c.arg "all"                       "set category to find"]     \
                                    ]
    set CMDLINE(search_usage)       "Search \[options] <search_string> ...\noptions:"

    set CMDLINE(install_options)    [list  \
                                        [list installdir.arg  ${::TSM::INSTALLDIR}    "set the installdir"] \
                                    ]
    set CMDLINE(install_usage)      "Install \[options] <script_name> ...\noptions:"
  
}
::TSM::main
