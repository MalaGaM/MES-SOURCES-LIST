#!/usr/bin/env tclsh
###############################################################################################
#
#	Name		:
#		TSM (TCL-SCRIPT-MANAGER)
#
#	Description	:
#		TSM (TCL-SCRIPT-MANAGER) is a terminal TCL script manager that allows you to easily install, update and uninstall TCL scripts.
#       It is based on a system of "source lists" containing catalogs of customizable scripts (on git), like a kind of APT for TCL Eggdrop script.
#
#		TSM (TCL-SCRIPT-MANAGER) est un gestionnaire de scripts TCL en terminal qui vous permet d'installer, de mettre à jour et de désinstaller facilement des scripts TCL.
#       Il est basé sur un système de "sources listes" contenant des catalogues de scripts (sur git) personnalisables, comme un genre de APT pour script TCL Eggdrop.
#
#	Donation	:
#		https://github.com/MalaGaM/DONATE
#
#	Website		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER
#
#	Support		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/issues
#
#	Docs		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/wiki
#
###############################################################################################
namespace eval ::TSM {
    variable ::TSM::DBSource [dict create]

    variable SCRIPTS
    array set SCRIPTS {
        NAME    "TSM"
        LNAME   "TCL-SCRIPT-MANAGER"
        VERSION "0.0.1"
    }

    variable ::TSM::CONFIG
    array set CONFIG {
        FILENAME    "TSM.cfg"
        
    }
    set CONFIG(PathList)    [list           \
                                [pwd]       \
                                [glob ~]    \
                                "/etc/tsm"  \
                                "/usr/etc"  \
                            ];

    variable ::TSM::SOURCE
    set SOURCE(PathList)    [list               \
                                [pwd]           \
                                [glob ~]        \
                                "/etc/tsm"      \
                                "/usr/etc/tsm" 
                            ];

    variable ::TSM::CMDLINE
    set CMDLINE(list_options) {
        {l.arg  "5"     "set the limit to show"}
        {c.arg  "all"   "set category to find"}
    }
    set CMDLINE(list_usage) "List \[options] <search_string> ...\noptions:"

    set CMDLINE(search_options) {
        {l.arg  "5"     "set the limit to show"}
        {c.arg  "all"   "set category to find"}
    }
    set CMDLINE(search_usage) "Search \[options] <search_string> ...\noptions:"

    set CMDLINE(install_options) {
        {installdir.arg  ""     "set the installdir"}
    }
    set CMDLINE(install_usage) "Install \[options] <script_name> ...\noptions:"
}

#########
namespace eval ::TSM::FCT {
    namespace export * 
}
proc ::TSM::FCT::run_exec args {
    return [exec -ignorestderr -- {*}$args]
}
# Run ${code} in the directory ${path}.
proc ::TSM::FCT::with-path {path code} {
    set prevPath [pwd]
    try {
        cd ${path}
        uplevel 1 ${code}
    } finally {
        cd ${prevPath}
    }
}
proc ::TSM::FCT::SCRIPT:GET:VALUE { SCRIPT_ID } {
    variable ::TSM::DBSource
    set DB_DATA [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    if { [string is entier ${SCRIPT_ID}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${SCRIPT_ID}] } {
        return -1
    }
    return [dict get ${DB_DATA} SCRIPTS_INDEX $SCRIPT_ID]
}
proc ::TSM::FCT::SCRIPT:GET:ID { Value } {
    variable ::TSM::DBSource
    set DB_DATA [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    set found 1
    if { [string is entier ${Value}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${Value}] } {
        return -1
    } elseif { ![string is entier ${Value}] } {
        set found 0
        dict for {id info} [dict get ${DB_DATA} SCRIPTS_INDEX] {
            dict with info {
                if { [string match -nocase ${Value} ${CODENAME}] } {
                    return ${id}
                }
            }
        }
    }
    if { ! ${found} } {
        return -1
    } else {
        return ${Value}
    }
}
proc ::TSM::FCT::VALUE:DEFAULT { Value {default NONE} } {
    return [expr { ${Value} ne "" ? ${Value} : ${default} }]
}
proc ::TSM::FCT::VALUE:DEFAULT:REVERSE { Value {default NONE} } {
    if { [llength ${Value}] == 0 } { return ${default} }
}
proc ::TSM::FCT::SPACE:TEXT { text length } {
	set text			[string trim $text]
    set text_length		[string length $text]
    if { [expr {$text_length % 2}] } { 
        set text_length		[expr [string length $text]+1]
        set text            "$text "
    }
	
	# si le $text est plus grand que $length on le retourne on le coupe avec deux points
	if { $text_length > $length } { set text "[string range $text 0 [expr $length-3]].." }
	# si le text a une longueur impair, on rajoute un space derriere
	if { [expr {($text_length % 2) != 0}] } { set text " $text" }
	
	set espace_length	[expr ($length - $text_length)/2]
	set espace			[string repeat " " $espace_length]; 
	return $espace$text$espace 
}

proc ::TSM::FCT::GETCONFIG { key {subkey ""} {default NONE} } {
    variable ::TSM::CONFIG
    return [::TSM::FCT::GET:VALUE ${CONFIG(DATA)} $key $subkey $default]
}
proc ::TSM::FCT::GET:VALUE { DB key {subkey ""} {default NONE}} {
    if { [dict exists ${DB} ${key}] } {
        if { ${subkey} == "" } {
            return [dict get ${DB} ${key}];
        }
        set SUBLIST [dict get ${DB} ${key}];
        if {[dict exists ${SUBLIST} ${subkey}]} {
            return [dict get ${SUBLIST} ${subkey}];
        } elseif {${default} ne {NONE}} {
            return ${default}
        } else {
            error [list no subkey ${subkey} for ${key} in config];
        }
    } elseif { ${default} ne {NONE} } {
        return ${default}
    } else {
        error [list no key ${key} in config];
    }
}
#########
namespace eval ::TSM::Show {}
proc ::TSM::Show::Banner {} {
    puts "  _____ ___ __  __ \n |_   _/ __|  \\/  |\n   | | \\__ \\ |\\/| |\n   |_| |___/_|  |_|\n-TCL-SCRIPT-MANAGER-"
}
proc ::TSM::Show::Help {} {
    puts "This script expects a parameter. Use:"
    ::TSM::COMMANDS::Help::UpdateDB
    ::TSM::COMMANDS::Help::List
    ::TSM::COMMANDS::Help::Search
    ::TSM::COMMANDS::Help::Show
    ::TSM::COMMANDS::Help::Install
    ::TSM::COMMANDS::Help::GenDateNow
    ::TSM::COMMANDS::Help::Main
}
proc ::TSM::Show::Error { ERR_MSG {exit 0} } {
    puts "ERROR: ${ERR_MSG}"
    if { ${exit} != 0 } { exit ${exit} }
 
}
#########
namespace eval ::TSM::Source {}
proc ::TSM::Source::Get:FILENAME:Path {} {
    variable ::TSM::SOURCE
    namespace import -force ::TSM::FCT::*
    # Chargement en cascade
    set SOURCE_LIST [list]
    foreach SOURCE_PATH ${SOURCE(PathList)} {
        set SOURCE_PATH [file normalize ${SOURCE_PATH}]
        if { [file exists "${SOURCE_PATH}/sources.list"] && [::TSM::File::Check:Perms "${SOURCE_PATH}/sources.list"] } {
            lappend SOURCE_LIST "${SOURCE_PATH}/sources.list"
        }
        if { [file isdirectory "${SOURCE_PATH}/sources.list.d"] } {
            foreach SOURCE_PATH_DIR "${SOURCE_PATH}/sources.list.d" { 
                foreach SOURCE_PATH_LIST [glob -nocomplain -directory ${SOURCE_PATH_DIR} *.list] { 
                    if { [file exists ${SOURCE_PATH_LIST}] } { lappend SOURCE_LIST ${SOURCE_PATH_LIST} }
                }
            }
        }
    }
    
    foreach SOURCE_FILE [GETCONFIG sources] {
        if { [string match http* ${SOURCE_FILE}] } {
            lappend SOURCE_LIST ${SOURCE_FILE}
        } else {
            lappend SOURCE_LIST [file normalize ${SOURCE_FILE}]
        }
    }
    set SOURCE(LIST) [lsort -unique ${SOURCE_LIST}]
}
#########
namespace eval ::TSM::List {}
proc ::TSM::List::Validator { SOURCE_LIST_DATA SOURCE_URI } {
    if { ![dict exists ${SOURCE_LIST_DATA} list] } { 
        ::TSM::Show::Error "Bad Source List file : No 'list' information in ${SOURCE_URI}" 0
        return 0
    }
    if { ![dict exists ${SOURCE_LIST_DATA} scripts] } { 
        ::TSM::Show::Error "Bad Source List file : No 'scripts' information in ${SOURCE_URI}" 0
        return 0
    }
    return 1
}
proc ::TSM::List::Read {} {
    variable ::TSM::SOURCE
    set SOURCE(SCRIPT_NUMBER)   0
    set SOURCE(LIST_NUMBER)     0
    foreach SOURCE_URI ${SOURCE(LIST)} {
        puts [format "Reading Source file from '%s'..." ${SOURCE_URI}]
        if { [string match http* ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA [::TSM::URL::Read:json2dict ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ![::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            incr SOURCE(LIST_NUMBER)
        } elseif { [::TSM::File::Check:Perms ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA    [::TSM::File::Read:json2dict ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ! [::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            incr SOURCE(LIST_NUMBER)
        } else {
            ::TSM::Show::Error "::TSM::List::Read ERROR: The file '${SOURCE_URI}' can't read!" 0
            continue
        }
    }
    puts "Total lists '${SOURCE(LIST_NUMBER)}' withs scripts: '${SOURCE(SCRIPT_NUMBER)}'"
    ::TSM::DBSource::save ${::TSM::SCRIPTS(NAME)}.db
}
proc ::TSM::List::Get:Informations { LIST_DATA SOURCE_URI } {
    variable ::TSM::SOURCE
    variable ::TSM::DBSource
    set LIST_NAME       ""
    set LIST_CONTACT    ""
    set LIST_DATE       ""
    set SCRIPTS_CNT     0
    if { [dict exists ${LIST_DATA} scripts] && [dict get ${LIST_DATA} scripts] == "" } { ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: No scripts informations found in ${SOURCE_URI}. skipped!"; return 0 }
    if { [dict exists ${LIST_DATA} list] } { 
        set list    [dict get ${LIST_DATA} list]
        if { [dict exists ${list} name] }       { 
            set LIST_NAME [dict get ${list} name] 
            if { [::TSM::DBSource::exists ${LIST_NAME}] } {
                ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: Duplicata source '${SOURCE_URI}' with '[::TSM::DBSource::get_data ${LIST_NAME} source]', skipped!"; return 0
            }
        }
        if { [dict exists ${list} contact] }    { set LIST_CONTACT [dict get ${list} contact] }
        if { [dict exists ${list} updateat] }   { set LIST_DATE [dict get ${list} updateat] }
        
            dict set DBSource ${LIST_NAME} updateat ${LIST_DATE}
            dict set DBSource ${LIST_NAME} contact ${LIST_CONTACT}
            dict set DBSource ${LIST_NAME} source ${SOURCE_URI}
    } else { ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: No List informations found in ${SOURCE_URI}"; return 0 }
    if { [dict exists ${LIST_DATA} scripts] } { 
        set SCRIPTS_LIST            [dict get ${LIST_DATA} scripts]
        foreach SCRIPT_DATA ${SCRIPTS_LIST} { 
            set SCRIPT_NAME             ""
            set SCRIPT_CATEGORY         ""
            set SCRIPT_DESCRIPTION      ""
            set SCRIPT_VERSION          ""
            set SCRIPT_AUTHOR           ""
            set SCRIPT_GITURL           ""
            set SCRIPT_GITREVISION      "master2"
            set SCRIPT_DOCS             NONE
            set SCRIPT_TROUBLESHOOTING  NONE
            set SCRIPT_MIN_VERS_EGG     NONE
            set SCRIPT_MIN_VERS_TCL     NONE
            set SCRIPT_PKG_REQUIRE      NONE
            set SCRIPT_POST_INSTALL     NONE
            if { [dict exists ${SCRIPT_DATA} name] }                { set SCRIPT_NAME               [dict get ${SCRIPT_DATA} name] }
            if { ${SCRIPT_NAME} == "" } { continue }
            if { [dict exists ${SCRIPT_DATA} category] }            { set SCRIPT_CATEGORY           [dict get ${SCRIPT_DATA} category] }
            if { [dict exists ${SCRIPT_DATA} description] }         { set SCRIPT_DESCRIPTION        [dict get ${SCRIPT_DATA} description] }
            if { [dict exists ${SCRIPT_DATA} version] }             { set SCRIPT_VERSION            [dict get ${SCRIPT_DATA} version] }
            if { [dict exists ${SCRIPT_DATA} author] }              { set SCRIPT_AUTHOR             [dict get ${SCRIPT_DATA} author] }
            if { [dict exists ${SCRIPT_DATA} documentation] }       { set SCRIPT_DOCS               [dict get ${SCRIPT_DATA} documentation] }
            if { [dict exists ${SCRIPT_DATA} giturl] }              { set SCRIPT_GITURL             [dict get ${SCRIPT_DATA} giturl] }
            if { [dict exists ${SCRIPT_DATA} gitrevision] }         { set SCRIPT_GITREVISION        [dict get ${SCRIPT_DATA} gitrevision] }
            if { [dict exists ${SCRIPT_DATA} troubleshooting] }     { set SCRIPT_TROUBLESHOOTING    [dict get ${SCRIPT_DATA} troubleshooting] }
            if { [dict exists ${SCRIPT_DATA} mineggdropversion] }   { set SCRIPT_MIN_VERS_EGG       [dict get ${SCRIPT_DATA} mineggdropversion] }
            if { [dict exists ${SCRIPT_DATA} mintclversion] }       { set SCRIPT_MIN_VERS_TCL       [dict get ${SCRIPT_DATA} mintclversion] }
            if { [dict exists ${SCRIPT_DATA} packagesrequire] }     { set SCRIPT_PKG_REQUIRE        [dict get ${SCRIPT_DATA} packagesrequire] }
            if { [dict exists ${SCRIPT_DATA} postinstalltext] }     { set SCRIPT_POST_INSTALL       [dict get ${SCRIPT_DATA} postinstalltext] }
            incr SOURCE(SCRIPT_NUMBER)
            incr SCRIPTS_CNT
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCENAME ${LIST_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCEDATE ${LIST_DATE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCECONTACT ${LIST_CONTACT}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODENAME ${SCRIPT_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODEVERS ${SCRIPT_VERSION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CATEGORY ${SCRIPT_CATEGORY}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DESCRIPTION ${SCRIPT_DESCRIPTION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} AUTHOR ${SCRIPT_AUTHOR}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DOCS ${SCRIPT_DOCS}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} GITURL ${SCRIPT_GITURL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} GITREVISION ${SCRIPT_GITREVISION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} TROUBLESHOOTING ${SCRIPT_TROUBLESHOOTING}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_EGG ${SCRIPT_MIN_VERS_EGG}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_TCL ${SCRIPT_MIN_VERS_TCL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} PKG_REQUIRE ${SCRIPT_PKG_REQUIRE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} POST_INSTALL ${SCRIPT_POST_INSTALL}
        }
    }
    dict set DBSource ${LIST_NAME} SCRIPTS_CNT ${SCRIPTS_CNT}
    puts [format "Informations list: '%s' by '%s' with '%s' scripts Last update: '%s'" ${LIST_NAME} ${LIST_CONTACT} ${SCRIPTS_CNT} ${LIST_DATE}]
    return 1
}
#########
namespace eval ::TSM::JSon {}
proc ::TSM::JSon::Valid { FILENAME JSON_DATA } {
    if { ![::json::validate ${JSON_DATA}] || [llength ${JSON_DATA}] == 0} {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an JSON FILE!"
    }
    if { [catch { ::json::json2dict ${JSON_DATA} } ERR_MSG] } {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an correct format JSON FILE! (JSON ERROR FORMAT)"
  }
    return 1
}
#########
namespace eval ::TSM::File {}
proc ::TSM::File::Read:json2dict { FILENAME } {
    set FILE_DATA   [::TSM::File::Read:Data ${FILENAME}]
    if { [catch {
                    ::TSM::JSon::Valid ${FILENAME} ${FILE_DATA}
    } ERROR_MSG] } { 
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${FILE_DATA}];
}
proc ::TSM::File::Read:Data { FILENAME } {
    set FILE_PIPE [open ${FILENAME} r]
    set FILE_DATA [read ${FILE_PIPE}]
    close ${FILE_PIPE}
    return ${FILE_DATA}
}
proc ::TSM::File::Check:Perms { FILENAME {exit 0} } {
    if { ![file isfile ${FILENAME}] } { ::TSM::Show::Error "'${FILENAME}' is not an file." ${exit}; } 
    if { ![file readable  ${FILENAME}] } { ::TSM::Show::Error "'${FILENAME}' is not readable file. check perms" ${exit}; } 
    return 1
}
#########
    # https://boulets.eggdrop.fr/tcl/routines/tcl-toolbox-0033.html
namespace eval ::TSM::DBSource {}
###############################################################################
### Crée une entrée dans la base de données.
###############################################################################

###############################################################################
### Supprime une catégorie et ses sous-catégories dans la base de données.
###############################################################################
proc ::TSM::DBSource::delete_entry {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } elseif { ![::tcl::dict::exists ${DBSource} {*}${args}] } {
        return -code error "entrée inexistante"
    } else {
        if { [catch { ::tcl::dict::unset DBSource {*}${args} }] } {
            return -code error "entrée inexistante"
        }
    }
}
###############################################################################
### Affiche les entrées que contiennent une catégorie dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_entries {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error  "base de données vide"
    } else {
        if { [catch { ::tcl::dict::keys [::tcl::dict::get ${DBSource} {*}${args}] } result ] } {
            return -code error "catégorie inexistante"
        } else {
            return ${result}
        }
    }
}
###############################################################################
### Affiche la valeur d'une entrée dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_data {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } else {
        if { [catch { ::tcl::dict::get ${DBSource} {*}${args} } result] } {
            return -code error "catégorie inexistante"
        } else {
            return ${result}
        }
    }
}
proc ::TSM::DBSource::exists {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return 0
    } else {
        if { [catch { ::tcl::dict::get ${DBSource} {*}${args} } result] } {
            return 0
        } else {
            return 1
        }
    }
}
proc ::TSM::DBSource::save { DB_FILE } {
    variable ::TSM::DBSource
    set FILE_PIPE       [open ${DB_FILE} w];
    fconfigure ${FILE_PIPE} -translation binary;
    puts -nonewline ${FILE_PIPE} ${DBSource}
    close ${FILE_PIPE}
}
proc ::TSM::DBSource::restore { DB_FILE } {
    variable ::TSM::DBSource
    set FILE_PIPE   [open ${DB_FILE} r];
    set FILE_DATA   [gets ${FILE_PIPE}];
    set DBSource    [dict get ${FILE_DATA}]
    
    close ${FILE_PIPE}
    return ${DBSource}
}
###############################################################################
### Incrémente une entrée numérique dans la base de données.
### L'incrément peut être une valeur négative et/ou décimale.
###############################################################################
proc ::TSM::DBSource::incr_value {args} {
    if { ![::tcl::string::is double [set increment [lindex ${args} end]]] } {
        return -code error "l'incrément doit être numérique"
    } else {
        set args [lreplace ${args} end end]
        variable ::TSM::DBSource
        if { ![::tcl::info::exists DBSource] } {
            return -code error "base de données vide"
        } else {
            if { ![::tcl::dict::exists ${DBSource} {*}${args}] } {
                return -code error "entrée inexistante"
            } elseif { ![::tcl::string::is double [::tcl::dict::get ${DBSource} {*}${args}]] } {
                return -code error "la valeur de cette entrée n'est pas numérique"
            } elseif { [catch { ::tcl::dict::set DBSource {*}${args} [expr {[::tcl::dict::get ${DBSource} {*}${args}] + ${increment}}] } result] } {
                return -code error "catégorie inexistante"
            } else {
                return ${result}
            }
        }
    }
}
#########
namespace eval ::TSM::Config {}
proc ::TSM::Config::Locate:FILENAME {} {
    variable ::TSM::CONFIG
    # Chargement unique (non en cascade)
    foreach CONFIG_PATH ${CONFIG(PathList)} {
        if { [file exists "${CONFIG_PATH}/${CONFIG(FILENAME)}"] } { return "${CONFIG_PATH}/${CONFIG(FILENAME)}" }
    }
    return -code error "Config file '${CONFIG(FILENAME)}' not found. Rename 'TSM.example.cfg' to '${CONFIG(FILENAME)}' and edit it!"
}
proc ::TSM::Config::Check {} {
    variable ::TSM::CONFIG
    variable ::TSM::SOURCE
    if { ![dict exists ${CONFIG(DATA)} sources] } { 
        ::TSM::Show::Error "No sources list in '${CONFIG(FILENAME)}' file." 2;
    }
}
proc ::TSM::Config::Load {} {
    variable ::TSM::CONFIG
    if { [ catch {
        set CONFIG(FilePath) [::TSM::Config::Locate:FILENAME]
    } ERROR_MSG ] } {
        puts "ERROR: ${ERROR_MSG}"
        return 
    }
    puts [format "Reading Config file from '%s'..." ${CONFIG(FilePath)}]
    ::TSM::File::Check:Perms ${CONFIG(FilePath)}
    set CONFIG(DATA) [::TSM::File::Read:json2dict ${CONFIG(FilePath)}]
}
#########
namespace eval ::TSM::URL {}
proc ::TSM::URL::Read:json2dict { URL } {
    if { [string match https* ${URL}] } { ::http::register https 443 [list ::tls::socket -tls1 1 -autoservername 1] }
    if { [catch {set URL_TOKEN [::http::geturl ${URL} -binary 1]} ERR_MSG] } {
		return -code error "::TSM::URL::Read:json2dict ERROR: ${ERR_MSG} for '${URL}'."
	}
    set URL_DATA    [::http::data ${URL_TOKEN}];
    ::http::cleanup ${URL_TOKEN}
    if { [string match https* ${URL}] } { ::http::unregister https }
    if { [catch { 
                    ::TSM::JSon::Valid ${URL} ${URL_DATA}
    } ERROR_MSG] } {
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${URL_DATA}];
}
#########
namespace eval ::TSM::PKG {}

proc ::TSM::PKG::Load { PKG_NAME {PKG_VERS ""} } {
    if { ${PKG_VERS} == "" && [catch { package require ${PKG_NAME} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} (${ERR})" 2
    } elseif { ${PKG_VERS} != "" && [catch { package require ${PKG_NAME} ${PKG_VERS} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} ${PKG_VERS} (${ERR})" 2
    }
}
#########
namespace eval ::TSM::COMMANDS {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::COMMANDS::UpdateDB {} {
    ::TSM::Source::Get:FILENAME:Path
    ::TSM::List::Read
}
proc ::TSM::COMMANDS::GenDateNow {} {
    puts "[clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S %Z" -gmt 1]"
}
proc ::TSM::COMMANDS::List { SEARCH_TEXT } {
    variable ::TSM::DBSource
    variable ::TSM::CMDLINE
    try {
        array set params [::cmdline::getoptions SEARCH_TEXT ${CMDLINE(list_options)} ${CMDLINE(list_usage)}]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    set found 0
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    puts "|   ID   |      Name      |     version      |    Category    |                    Descripstion                    |         Repo         |"
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    dict for {id info} [dict get ${DB_DATA} SCRIPTS_INDEX] {
        dict with info {
            if { 
                [string match -nocase "*${SEARCH_TEXT}*" ${CODENAME}] \
                && ( [string match -nocase "all" ${params(c)}] || [string match -nocase ${params(c)} ${CATEGORY} ] )
            } {
                if { ${found} >= ${params(l)} } { break }
                set MSG     "| [SPACE:TEXT ${id} 6] "
                append MSG  "| [SPACE:TEXT ${CODENAME} 14] "
                append MSG  "| [SPACE:TEXT ${CODEVERS} 16] "
                append MSG  "| [SPACE:TEXT ${CATEGORY} 14] "
                append MSG  "| [SPACE:TEXT ${DESCRIPTION} 50] "
                append MSG  "| [SPACE:TEXT ${SOURCENAME} 20] |"
                puts ${MSG}
                incr found
            }
            
        }

    }
    if { $found == 0 } { 
        puts "|    -   |       -        |        -         |       ALL      |                Nohting found ...                   |          ALL         |"
    }
    puts "*--------*----------------*------------------*----------------*---------------------------*------------------------*----------------------*"
    puts "| [SPACE:TEXT "Help: ${::argv0} List -help" 42] | [SPACE:TEXT "Category: ${params(c)}" 42] | [SPACE:TEXT "Limit: ${params(l)}" 44]  |"
    puts "*--------------------------------------------*--------------------------------------------*-----------------------------------------------*"
    puts "* For more information on a script: ${::argv0} show <ID|Name>"
}
proc ::TSM::COMMANDS::Search { SEARCH_TEXT } {
    variable ::TSM::DBSource
    variable ::TSM::CMDLINE
    try {
        array set params [::cmdline::getoptions SEARCH_TEXT ${CMDLINE(search_options)} ${CMDLINE(search_usage)}]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    set found 0
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    puts "|   ID   |      Name      |     version      |    Category    |                    Descripstion                    |         Repo         |"
    puts "*--------*----------------*------------------*----------------*----------------------------------------------------*----------------------*"
    dict for {id info} [dict get ${DB_DATA} SCRIPTS_INDEX] {
        dict with info {
            if { 
                [string match -nocase "*${SEARCH_TEXT}*" ${DESCRIPTION}] \
                && ( [string match -nocase "all" ${params(c)}] || [string match -nocase ${params(c)} ${CATEGORY} ] )
            } {
                if { ${found} >= ${params(l)} } { break }
                set MSG     "| [SPACE:TEXT ${id} 6] "
                append MSG  "| [SPACE:TEXT ${CODENAME} 14] "
                append MSG  "| [SPACE:TEXT ${CODEVERS} 16] "
                append MSG  "| [SPACE:TEXT ${CATEGORY} 14] "
                append MSG  "| [SPACE:TEXT ${DESCRIPTION} 50] "
                append MSG  "| [SPACE:TEXT ${SOURCENAME} 20] |"
                puts ${MSG}
                incr found
            }
        }
    }
    if { $found == 0 } { 
        puts "|    -   |       -        |        -         |       ALL      |                Nohting found ...                   |          ALL         |"
    }
    puts "*--------*----------------*------------------*----------------*---------------------------*------------------------*----------------------*"
    puts "| [SPACE:TEXT "Help: ${::argv0} List -help" 42] | [SPACE:TEXT "Category: ${params(c)}" 42] | [SPACE:TEXT "Limit: ${params(l)}" 44]  |"
    puts "*--------------------------------------------*--------------------------------------------*-----------------------------------------------*"
    puts "* For more information on a script: ${::argv0} show <ID|Name>"
}
proc ::TSM::COMMANDS::Install { args } {
    variable ::TSM::CMDLINE
    try {
        array set params [::cmdline::getoptions args ${CMDLINE(install_options)} ${CMDLINE(install_usage)}]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA     [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    set SCRIPT_ID   [::TSM::FCT::SCRIPT:GET:ID ${args}]
    set SCRIPT_DATA [::TSM::FCT::SCRIPT:GET:VALUE ${SCRIPT_ID}]
    puts $SCRIPT_DATA
    with-path [GETCONFIG eggdrop installdir] {
        run_exec git clone [GET:VALUE ${SCRIPT_DATA} GITURL] [GET:VALUE ${SCRIPT_DATA} CODENAME]
        with-path [GET:VALUE ${SCRIPT_DATA} CODENAME] {
            run_exec git fetch [GET:VALUE ${SCRIPT_DATA} GITURL] [GET:VALUE ${SCRIPT_DATA} GITREVISION]
            run_exec git checkout [GET:VALUE ${SCRIPT_DATA} GITREVISION]
            set commit [run_exec git rev-parse HEAD]
        }

    }
    puts $commit


}    
proc ::TSM::COMMANDS::Show { STR_SEARCH } {
    variable ::TSM::DBSource
    set DB_DATA [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    set found 1
    if { [string is entier ${STR_SEARCH}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${STR_SEARCH}] } {
        ::TSM::Show::Error "${::argv0} Show: script ID '${STR_SEARCH}' no found" 2
    } elseif { ![string is entier ${STR_SEARCH}] } {
        set found 0
        dict for {id info} [dict get ${DB_DATA} SCRIPTS_INDEX] {
            dict with info {
                if { [string match -nocase ${STR_SEARCH} ${CODENAME}] } {
                    set STR_SEARCH ${id}
                    set found 1
                    break
                }
            }
        }
    }
    if { ! ${found} } {
        ::TSM::Show::Error "${::argv0} Show: script Name '${STR_SEARCH}' no found" 2
    }
    set SCRIPT_DATA [dict get ${DB_DATA} SCRIPTS_INDEX ${STR_SEARCH}]
    dict with SCRIPT_DATA {
        puts ""
        puts "****** SOURCE INFORMATIONS ******"
        puts ""
        puts "[SPACE:TEXT "NAME" 30]: [VALUE:DEFAULT ${SOURCENAME}]"
        puts "[SPACE:TEXT "DATE" 30]: [VALUE:DEFAULT ${SOURCEDATE}]"
        puts "[SPACE:TEXT "CONTACT" 30]: [VALUE:DEFAULT ${SOURCECONTACT}]"
        puts ""
        puts "****** SCRIPT INFORMATIONS ******"
        puts ""
        puts "[SPACE:TEXT "ID" 30]: [VALUE:DEFAULT ${STR_SEARCH}]"
        puts "[SPACE:TEXT "NAME" 30]: [VALUE:DEFAULT ${CODENAME}]"
        puts "[SPACE:TEXT "VERSION" 30]: [VALUE:DEFAULT ${CODEVERS}]"
        puts "[SPACE:TEXT "CATEGORY" 30]: [VALUE:DEFAULT ${CATEGORY}]"
        puts "[SPACE:TEXT "DESCRIPTION" 30]: [VALUE:DEFAULT ${DESCRIPTION}]"
        puts "[SPACE:TEXT "AUTHOR" 30]: [VALUE:DEFAULT ${AUTHOR}]"
        puts "[SPACE:TEXT "GIT URL" 30]: [VALUE:DEFAULT ${GITURL}]"
        puts "[SPACE:TEXT "GIT REVISION" 30]: [VALUE:DEFAULT ${GITREVISION}]"
        puts "[SPACE:TEXT "TROUBLESHOOTING" 30]: [VALUE:DEFAULT ${TROUBLESHOOTING}]"
        puts "[SPACE:TEXT "Minimum version for Eggdrop" 30]: [VALUE:DEFAULT ${MIN_VERS_EGG}]"
        puts "[SPACE:TEXT "Minimum version for TCL" 30]: [VALUE:DEFAULT ${MIN_VERS_TCL}]"
        puts ""
        puts "****** Packages Required ******"
        puts "[VALUE:DEFAULT:REVERSE ${PKG_REQUIRE}]"
        
        dict for {PKG_NAME PKG_VERS} ${PKG_REQUIRE} {
            puts "[SPACE:TEXT "${PKG_NAME}" 30]: [VALUE:DEFAULT ${PKG_VERS}]"
        }
        puts ""
        puts "****** post-installation INFORMATIONS ******"
        puts "[VALUE:DEFAULT:REVERSE ${POST_INSTALL}]"
        foreach {INSTALL_TEXT} ${POST_INSTALL} {
            puts "      ${INSTALL_TEXT}"
        }
        puts ""
        puts "*********************************"
    }
}
#########
namespace eval ::TSM::COMMANDS::Help {}
proc ::TSM::COMMANDS::Help { args } {
    set COMMANDS    [lindex ${args} 0]
    set SUBCOMMANDS [lrange ${args} 1 end]
    switch -nocase ${COMMANDS} {
        UpdateDB  {
            ::TSM::COMMANDS::Help::UpdateDB 1
        }
        List  {
            ::TSM::COMMANDS::Help::List 1
        }
        Search  {
            ::TSM::COMMANDS::Help::Search 1
        }
        GenDateNow  {
            ::TSM::COMMANDS::Help::GenDateNow 1
        }
        Install  {
            ::TSM::COMMANDS::Help::Install 1
        }
        Show  {
            ::TSM::COMMANDS::Help::Show 1
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::COMMANDS::Help::UpdateDB    { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} UpdateDB               - Update database list of available scripts"
}
proc ::TSM::COMMANDS::Help::Search    { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Search <search_string> - Search in scripts descriptions"
    if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(search_options)} ${::TSM::CMDLINE(search_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::List        { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} List   <search_string> - List scripts based on script names"
    if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(list_options)} ${::TSM::CMDLINE(list_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::Main  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} help       <parameter> - Show help for <parameter>"
}
proc ::TSM::COMMANDS::Help::Install  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Install          <num> - Install script"
       if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(install_options)} ${::TSM::CMDLINE(install_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::GenDateNow  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} GenDateNow             - Generator date now with format '%a, %d %b %Y %H:%M:%S %Z'"
}
proc ::TSM::COMMANDS::Help::Show        { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Show        <Num|Name> - Show script details"
}
#########

proc ::TSM::main { } {
    variable ::TSM::SOURCE
    ::TSM::Init
    set COMMANDS    [lindex ${::argv} 0]
    set SUBCOMMANDS [lrange ${::argv} 1 end]
    switch -nocase ${COMMANDS} {
        UpdateDB  {
            ::TSM::COMMANDS::UpdateDB
        }
        List  {
            ::TSM::COMMANDS::List ${SUBCOMMANDS}
        }
        GenDateNow  {
            ::TSM::COMMANDS::GenDateNow
        }
        Show  {
            ::TSM::COMMANDS::Show ${SUBCOMMANDS}
        }
        Search  {
            ::TSM::COMMANDS::Search ${SUBCOMMANDS}
        }
        Install  {
            ::TSM::COMMANDS::Install ${SUBCOMMANDS}
        }
        Help  {
            ::TSM::COMMANDS::Help ${SUBCOMMANDS}
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::Init {} {
    ::TSM::PKG::Load Tcl 8.5
    ::TSM::PKG::Load json
    ::TSM::PKG::Load http
    ::TSM::PKG::Load tls
    ::TSM::PKG::Load cmdline 1.5
    ::TSM::Show::Banner
    ::TSM::Config::Load
    ::TSM::Config::Check
}
::TSM::main
