#!/usr/bin/env tclsh
###############################################################################################
#
#	Name		:
#		TSM (TCL-SCRIPT-MANAGER)
#
#	Description	:
#		TSM (TCL-SCRIPT-MANAGER) is a terminal TCL script manager that allows you to easily install, update and uninstall TCL scripts.
#       It is based on a system of "source lists" containing catalogs of customizable scripts (on git), like a kind of APT for TCL Eggdrop script.
#
#		TSM (TCL-SCRIPT-MANAGER) est un gestionnaire de scripts TCL en terminal qui vous permet d'installer, de mettre à jour et de désinstaller facilement des scripts TCL.
#       Il est basé sur un système de "sources listes" contenant des catalogues de scripts (sur git) personnalisables, comme un genre de APT pour script TCL Eggdrop.
#
#	Donation	:
#		https://github.com/ZarTek-Creole/DONATE
#
#	Website		:
#		https://github.com/ZarTek-Creole/TCL-SCRIPT-MANAGER
#
#	Support		:
#		https://github.com/ZarTek-Creole/TCL-SCRIPT-MANAGER/issues
#
#	Docs		:
#		https://github.com/ZarTek-Creole/TCL-SCRIPT-MANAGER/wiki
#
###############################################################################################
namespace eval ::TSM {
    variable ::TSM::DBSource [dict create]

    variable SCRIPTS
    array set SCRIPTS {
        NAME    "TSM"
        LNAME   "TCL-SCRIPT-MANAGER"
        VERSION "0.0.1"
    }
    set SCRIPTS(RUN_IN_PATH) [file dirname [file normalize [info script]]]
    set SCRIPTS(DB) "${SCRIPTS(RUN_IN_PATH)}/${SCRIPTS(NAME)}.db"
    variable ::TSM::CONFIG
    array set CONFIG {
        FILENAME    "TSM.cfg"
    }
    set CONFIG(PathList)    [list           \
                                [pwd]       \
                                ${SCRIPTS(RUN_IN_PATH)} \
                                [glob ~]    \
                                "/etc/tsm"  \
                                "/usr/etc"  \
                            ];

    variable ::TSM::SOURCE
    set SOURCE(PathList)    [list               \
                                [pwd]           \
                                ${SCRIPTS(RUN_IN_PATH)} \
                                [glob ~]        \
                                "/etc/tsm"      \
                                "/usr/etc/tsm" 
                            ];

}

#########
namespace eval ::TSM::FCT {
    namespace export * 
}
proc ::TSM::FCT::duration int_time {
    set timeList [list]
    foreach div {86400 3600 60 1} mod {0 24 60 60} name {day hr min sec} {
        set n [expr {$int_time / $div}]
        if {$mod > 0} {set n [expr {$n % $mod}]}
        if {$n > 1} {
            lappend timeList "$n ${name}s"
        } elseif {$n == 1} {
            lappend timeList "$n $name"
        }
    }
    return [join $timeList]
}
proc ::TSM::FCT::DICT-2-PRETTY-JSON value {
    # Guess the type of the value; deep *UNSUPPORTED* magic!
    regexp {^value is a (.*?) with a refcount} [::tcl::unsupported::representation ${value}] -> type
 
    switch ${type} {
        string {
            return [json::write string ${value}]
        }
        dict {
            return [json::write object {*}[
            dict map {k v} ${value} {DICT-2-PRETTY-JSON ${v}}]]
        }
        list {
            return [json::write array {*}[lmap v ${value} {DICT-2-PRETTY-JSON ${v}}]]
        }
        int - double {
            return [expr {${value}}]
        }
        booleanString {
            return [expr {${value} ? "true" : "false"}]
        }
        default {
            # Some other type; do some guessing...
            if {${value} eq "null"} {
                # Tcl has *no* null value at all; empty strings are semantically
                # different and absent variables aren't values. So cheat!
                return ${value}
            } elseif { [string is integer -strict ${value}] } {
                return [expr {${value}}]
            } elseif { [string is double -strict ${value}] } {
                return [expr {${value}}]
            } elseif { [string is boolean -strict ${value}] } {
                return [expr {${value} ? "true" : "false"}]
            }
            return [json::write string ${value}]
        }
    }
}
proc ::TSM::FCT::SCRIPT-IS-INSTALLED { SCRIPT_NAME  } {
    variable ::TSM::SCRIPTS
    set FILE_DATA    [File-Read ${SCRIPTS(RUN_IN_PATH)}/.TSM]
    foreach FILE_LINE [split ${FILE_DATA} "\n"] {
        set FILE_SCRIPT_NAME    [lindex ${FILE_LINE} 0]    
        if { [string match -nocase ${FILE_SCRIPT_NAME} ${SCRIPT_NAME}] } { return 1 }
    }
    return 0
}
proc ::TSM::FCT::SCRIPT-GET-VERSION-INSTALLED { SCRIPT_NAME {type version} } {
    variable ::TSM::SCRIPTS
    if { $type == "version" } { set v_index 2 } else { set v_index 1 }
    set FILE_DATA    [File-Read "${SCRIPTS(RUN_IN_PATH)}/.TSM"]
    foreach FILE_LINE [split ${FILE_DATA} "\n"] {
        set FILE_SCRIPT_NAME    [lindex ${FILE_LINE} 0]    
        if { [string match -nocase ${FILE_SCRIPT_NAME} ${SCRIPT_NAME}] } { 
            set FILE_SCRIPT_VERS    [lindex ${FILE_LINE} ${v_index}]    
            return ${FILE_SCRIPT_VERS}
        }
    }
    return null
}
proc ::TSM::FCT::SCRIPT-GET-STATUS { SCRIPT_NAME SCRIPT_VERS MIN_VERS_EGG MIN_VERS_TCL } {
    # SCRIPT-GET-STATUS ${CODENAME} ${MIN_VERS_EGG} ${MIN_VERS_TCL}
    set STATUS  ""
    # EGG
    if { ![VERSION-CHECK ${::TSM::EGGDROP_VERSION} ${MIN_VERS_EGG}] } {
        lappend STATUS  "E"
    }
    # TCL
    if { ![VERSION-CHECK ${::TSM::TCL_VERSION} ${MIN_VERS_TCL}] } {
        lappend STATUS  "T"
    }
    # INSTALLED
    if { [SCRIPT-IS-INSTALLED ${SCRIPT_NAME}] } {
        lappend STATUS  "I"
        if { ![VERSION-CHECK [SCRIPT-GET-VERSION-INSTALLED ${SCRIPT_NAME}] ${SCRIPT_VERS}] } {
            lappend STATUS  "U"
        }
    }

    if { ${STATUS} == "" } { return A }
    return ${STATUS}
}
proc ::TSM::FCT::VERSION-CHECK { CURVERS NEEDVERS } {
    if { [string match -nocase "null" ${NEEDVERS}] } {
        return 1
    } elseif { [package vcompare ${CURVERS} ${NEEDVERS}] == "-1" } {
        return  0
    }
    return 1
}
proc ::TSM::FCT::PKG-Load { PKG_NAME {PKG_VERS ""} } {
    if { ${PKG_VERS} == "" && [catch { package require ${PKG_NAME} } ERR] } { 
        ::TSM::Show::Error "${::argv0} need package ${PKG_NAME} (${ERR})" 2
    } elseif { ${PKG_VERS} != "" && [catch { package require ${PKG_NAME} ${PKG_VERS} } ERR] } { 
        ::TSM::Show::Error "${::argv0} need package ${PKG_NAME} ${PKG_VERS} (${ERR})" 2
    }
}
proc ::TSM::FCT::Git-COMMIT-VERSION { GITURL BRANCH } {
    set GIT_EXEC [list git ls-remote --heads ${GITURL} ${BRANCH}]
    return [lindex [exec -ignorestderr -- {*}${GIT_EXEC}] 0]
}
proc ::TSM::FCT::Git-Validator { GITURL BRANCH } {
    set GIT_EXEC [list git ls-remote --heads ${GITURL} ${BRANCH} | grep ${BRANCH} >/dev/null ]
    if { [catch {exec -ignorestderr -- {*}${GIT_EXEC}}] == 0} { return 1 }
    return 0
}
proc ::TSM::FCT::Git-Get-Default-Branch { GITURL } {
    if { [regexp {HEAD branch: (\w*)} [RUN-EXEC git remote show ${GITURL}] -> Branch] } {
        return ${Branch}
    }
    return -1
}
proc ::TSM::FCT::File-Read-JSon2Dict { FILENAME } {
    set FILE_DATA   [File-Read ${FILENAME}]
    if { ${FILE_DATA} == "-1" } { return -1 }
    if { [catch {
                    ::TSM::JSon::Valid ${FILENAME} ${FILE_DATA}
    } ERROR_MSG] } { 
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${FILE_DATA}];
}

proc ::TSM::FCT::File-Check-Permission { FILENAME {exit 0} {silent 0} } {
    if { ![file isfile ${FILENAME}] } { 
        if {  ${silent} == 0 } { ::TSM::Show::Error "'${FILENAME}' is not an file." ${exit};  }
        return 0
    } 
    if { ![file readable ${FILENAME}] } {
        if {  ${silent} == 0 } { ::TSM::Show::Error "'${FILENAME}' is not readable file. check perms" ${exit}; }
        return 0
    } 
    return 1
}

proc ::TSM::FCT::File-Write {path content {binary 0} {right "w"}} {
    set FILE_PIPE [open ${path} ${right}]
    if { ${binary} } {
        fconfigure ${FILE_PIPE} -translation binary
    }
    puts -nonewline ${FILE_PIPE} "${content}\n"
    close ${FILE_PIPE}
}

proc ::TSM::FCT::File-Read { FILENAME } {
    if { ![file exists $FILENAME] } { return -1 }
    set FILE_PIPE [open ${FILENAME} r]
    set FILE_DATA [read ${FILE_PIPE}]
    close ${FILE_PIPE}
    return ${FILE_DATA}
}
proc ::TSM::FCT::Get-URL-JSon2Dict { URL } {
    if { [string match https* ${URL}] } { ::http::register https 443 [list ::tls::socket -tls1 1 -autoservername 1] }
    if { [catch {set URL_TOKEN [::http::geturl ${URL} -binary 1]} ERR_MSG] } {
		return -code error "Get-URL-JSon2Dict: ${ERR_MSG} for '${URL}'."
	}
    set URL_DATA    [::http::data ${URL_TOKEN}];
    ::http::cleanup ${URL_TOKEN}
    if { [string match https* ${URL}] } { ::http::unregister https }
    if { [catch { 
                    ::TSM::JSon::Valid ${URL} ${URL_DATA}
    } ERROR_MSG] } {
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${URL_DATA}];
}
proc ::TSM::FCT::RUN-EXEC args {
    return [exec -ignorestderr -- {*}${args}]
}
# Run ${code} in the directory ${path}.
proc ::TSM::FCT::RUN-IN-PATH {path code} {
    set prevPath [pwd]
    try {
        puts "Changing the current directory to '${path}'."
        cd ${path}
        uplevel 1 ${code}
    } finally {
        puts "back to the directory '${prevPath}'"
        cd ${prevPath}
    }
}
proc ::TSM::FCT::SCRIPT-GET-VALUE { SCRIPT_ID } {
    variable ::TSM::DBSource
    variable ::TSM::SCRIPTS
    set DB_DATA [File-Read-JSon2Dict ${SCRIPTS(DB)}]
    if { [string is entier ${SCRIPT_ID}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${SCRIPT_ID}] } {
        return -1
    }
    return [VALUE-GET ${DB_DATA} SCRIPTS_INDEX ${SCRIPT_ID}]
}
proc ::TSM::FCT::SCRIPT-GET-ID { Value } {
    variable ::TSM::DBSource
    variable ::TSM::SCRIPTS
    set DB_DATA [File-Read-JSon2Dict ${SCRIPTS(DB)}]
    set found 1
    if { [string is entier ${Value}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${Value}] } {
        return -1
    } elseif { ![string is entier ${Value}] } {
        set found 0
        dict for {id info} [VALUE-GET ${DB_DATA} SCRIPTS_INDEX] {
            dict with info {
                if { [string match -nocase ${Value} ${CODENAME}] } {
                    return ${id}
                }
            }
        }
    }
    if { ! ${found} } {
        return -1
    } else {
        return ${Value}
    }
}
proc ::TSM::FCT::VALUE-DEFAULT { Value {default NONE} } {
    return [expr { ${Value} ne "" ? ${Value} : ${default} }]
}
proc ::TSM::FCT::VALUE-DEFAULT-REVERSE { Value {default NONE} } {
    if { [llength ${Value}] == 0 } { return ${default} }
}
proc ::TSM::FCT::VALUE-EXISTS {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return 0
    } else {
        if { [catch { ::tcl::dict::get ${DBSource} {*}${args} } result] } {
            return 0
        } else {
            return 1
        }
    }
}
proc ::TSM::FCT::VALUE-GET { DB key {subkey ""} {default NONE}} {
    if { [dict exists ${DB} ${key}] } {
        if { ${subkey} == "" } {
            return [dict get ${DB} ${key}];
        }
        set SUBLIST [dict get ${DB} ${key}];
        if {[dict exists ${SUBLIST} ${subkey}]} {
            return [dict get ${SUBLIST} ${subkey}];
        } elseif {${default} ne {NONE}} {
            return ${default}
        } else {
            error [list no subkey ${subkey} for ${key} in config];
        }
    } elseif { ${default} ne {NONE} } {
        return ${default}
    } else {
        error [list no key ${key} in config];
    }
}
proc ::TSM::FCT::TEXT-SPACE-SEP { text length } {
	set text			[string trim ${text}]
    set text_length		[string length ${text}]
    if { [expr {${text_length} % 2}] } { 
        set text_length		[expr [string length ${text}]+1]
        set text            "${text} "
    }
	
	# si le $text est plus grand que $length on le retourne on le coupe avec deux points
	if { ${text_length} > ${length} } { set text "[string range ${text} 0 [expr ${length}-3]].." }
	# si le text a une longueur impair, on rajoute un space derriere
	if { [expr {(${text_length} % 2) != 0}] } { set text " ${text}" }
	
	set espace_length	[expr (${length} - ${text_length})/2]
	set espace			[string repeat " " ${espace_length}]; 
	return ${espace}${text}${espace} 
}

proc ::TSM::FCT::CONFIG-GET { key {subkey ""} {default NONE} } {
    variable ::TSM::CONFIG
    return [VALUE-GET ${CONFIG(DATA)} ${key} ${subkey} ${default}]
}
proc ::TSM::FCT::DB-GET { cat key {subkey ""} {default NONE} } {
    variable ::TSM::SCRIPTS
    variable ::TSM::DBSource
    set DB  [VALUE-GET ${DBSource} ${cat}]
    return [VALUE-GET ${DB} ${key} ${subkey} ${default}]
}

#########
namespace eval ::TSM::Show {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::Show::Banner {} {
    puts "  _____ ___ __  __ \n |_   _/ __|  \\/  |\n   | | \\__ \\ |\\/| |\n   |_| |___/_|  |_|\n\n-TCL-SCRIPT-MANAGER-"
}

proc ::TSM::Show::Informations {} {
    variable ::TSM::DBSource
    variable ::TSM::SOURCE
    variable ::TSM::SCRIPTS
    set DBSource        [File-Read-JSon2Dict ${SCRIPTS(DB)}]
    if { ${DBSource} == "-1 " } {
        set DB_TEXT         "[string map [list [pwd] "."] ${SCRIPTS(DB)}]: NEVER UPDATED -> Run ${::argv0} UpdateDB"
        ::TSM::Show::Error "DB never updated! Run '${::argv0} UpdateDB ' before." [expr {[string match -nocase "UpdateDB" $::argv] ? 0 : 2}]
    } else {
        set DB_TIME_UNIX    [DB-GET DB Update At]
        set DB_TIME_DATE    [clock format ${DB_TIME_UNIX} -format "%m-%d-%Y" -gmt 1]
        set DB_TIME_AGO     [expr {[clock seconds]-${DB_TIME_UNIX}}]
        set DB_SCRIPT_CNT   [DB-GET DB Script Count]
        set DB_SOURCE_CNT   [DB-GET DB Source Count]
        set DB_TEXT         "[string map [list [pwd] "."] ${SCRIPTS(DB)}]: ${DB_TIME_DATE} ([duration ${DB_TIME_AGO}] ago) with ${DB_SCRIPT_CNT} scripts from ${DB_SOURCE_CNT} sources"
    }
    set DBSource ""

    puts "InstallDir : ${::TSM::INSTALLDIR}"
    puts "Eggdrop    : ${::TSM::EGGDROP_VERSION}"
    puts "TCL        : ${::TSM::TCL_VERSION}"
    puts "DB         : ${DB_TEXT}"
    puts "--------------------\n"
}
proc ::TSM::Show::Help {} {
    puts "This script expects a parameter. Use:"
    ::TSM::COMMANDS::Help::UpdateDB
    ::TSM::COMMANDS::Help::List
    ::TSM::COMMANDS::Help::Search
    ::TSM::COMMANDS::Help::Show
    ::TSM::COMMANDS::Help::Install
    ::TSM::COMMANDS::Help::GenDateNow
    ::TSM::COMMANDS::Help::Main
}
proc ::TSM::Show::Error { ERR_MSG {exit 0} } {
    puts "ERROR: ${ERR_MSG}"
    if { ${exit} != 0 } { exit ${exit} }
    return ${exit}
 
}
#########
namespace eval ::TSM::Source {}
proc ::TSM::Source::Get:FILENAME:Path {} {
    variable ::TSM::SOURCE
    variable ::TSM::CONFIG
    namespace import -force ::TSM::FCT::*
    # Chargement en cascade
    set SOURCE_LIST [list]
    foreach SOURCE_PATH ${SOURCE(PathList)} {
        set SOURCE_PATH [file normalize ${SOURCE_PATH}]
        if { [file exists "${SOURCE_PATH}/sources.list"] && [File-Check-Permission "${SOURCE_PATH}/sources.list" 0 1] } {
            lappend SOURCE_LIST "${SOURCE_PATH}/sources.list"
        }
        if { [file isdirectory "${SOURCE_PATH}/sources.list.d"] } {
            foreach SOURCE_PATH_DIR "${SOURCE_PATH}/sources.list.d" { 
                foreach SOURCE_PATH_LIST [glob -nocomplain -directory ${SOURCE_PATH_DIR} *.list] { 
                    if { [file exists ${SOURCE_PATH_LIST}] } { lappend SOURCE_LIST ${SOURCE_PATH_LIST} }
                }
            }
        }
    }
    
    foreach SOURCE_FILE [CONFIG-GET sources] {
        if { [string match http* ${SOURCE_FILE}] } {
            lappend SOURCE_LIST ${SOURCE_FILE}
        } elseif { [file exists ${SOURCE_FILE}] && [File-Check-Permission "${SOURCE_PATH}/sources.list" 0 1] } {
            lappend SOURCE_LIST [file normalize ${SOURCE_FILE}]
        } 
    }
    set SOURCE(LIST) [lsort -unique ${SOURCE_LIST}]
}
#########
namespace eval ::TSM::List {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::List::Validator { SOURCE_LIST_DATA SOURCE_URI } {
    if { ![dict exists ${SOURCE_LIST_DATA} list] } { 
        ::TSM::Show::Error "Bad Source List file : No 'list' information in ${SOURCE_URI}" 0
        return 0
    }
    if { ![dict exists ${SOURCE_LIST_DATA} scripts] } { 
        ::TSM::Show::Error "Bad Source List file : No 'scripts' information in ${SOURCE_URI}" 0
        return 0
    }
    return 1
}
proc ::TSM::List::Get:Informations { LIST_DATA SOURCE_URI } {
    variable ::TSM::SOURCE
    variable ::TSM::DBSource
    set LIST_NAME       ""
    set LIST_CONTACT    ""
    set LIST_DATE       ""
    set SCRIPTS_CNT     0
    if { [dict exists ${LIST_DATA} scripts] && [VALUE-GET ${LIST_DATA} scripts] == "" } { ::TSM::Show::Error "No scripts informations found in ${SOURCE_URI}. skipped!"; return 0 }
    if { [dict exists ${LIST_DATA} list] } { 
        set list    [VALUE-GET ${LIST_DATA} list]
        if { [dict exists ${list} name] }       { 
            set LIST_NAME [VALUE-GET ${list} name] 
            if { [VALUE-EXISTS ${LIST_NAME}] } {
                ::TSM::Show::Error "Duplicata source '${SOURCE_URI}' with '[VALUE-GET ${DBSource} ${LIST_NAME} source]', skipped!"; return 0
            }
        }
        if { [dict exists ${list} contact] }    { set LIST_CONTACT [VALUE-GET ${list} contact] }
        if { [dict exists ${list} updateat] }   { set LIST_DATE [VALUE-GET ${list} updateat] }
            dict set DBSource ${LIST_NAME} updateat ${LIST_DATE}
            dict set DBSource ${LIST_NAME} contact ${LIST_CONTACT}
            dict set DBSource ${LIST_NAME} source ${SOURCE_URI}
    } else { ::TSM::Show::Error "No List informations found in ${SOURCE_URI}"; return 0 }
    if { [dict exists ${LIST_DATA} scripts] } { 
        set SCRIPTS_LIST            [VALUE-GET ${LIST_DATA} scripts]
        foreach SCRIPT_DATA ${SCRIPTS_LIST} { 
            set SCRIPT_NAME             ""
            set SCRIPT_CATEGORY         ""
            set SCRIPT_DESCRIPTION      ""
            set SCRIPT_VERSION          ""
            set SCRIPT_AUTHOR           ""
            set SCRIPT_GITURL           ""
            set SCRIPT_GITREVISION      ""
            set SCRIPT_DOCS             NONE
            set SCRIPT_TROUBLESHOOTING  NONE
            set SCRIPT_MIN_VERS_EGG     NONE
            set SCRIPT_MIN_VERS_TCL     NONE
            set SCRIPT_PKG_REQUIRE      NONE
            set SCRIPT_POST_INSTALL     NONE
            if { [dict exists ${SCRIPT_DATA} name] }                { set SCRIPT_NAME               [VALUE-GET ${SCRIPT_DATA} name] }
            if { ${SCRIPT_NAME} == "" } { continue }
            if { [dict exists ${SCRIPT_DATA} category] }            { set SCRIPT_CATEGORY           [VALUE-GET ${SCRIPT_DATA} category] }
            if { [dict exists ${SCRIPT_DATA} description] }         { set SCRIPT_DESCRIPTION        [VALUE-GET ${SCRIPT_DATA} description] }
            if { [dict exists ${SCRIPT_DATA} version] }             { set SCRIPT_VERSION            [VALUE-GET ${SCRIPT_DATA} version] }
            if { [dict exists ${SCRIPT_DATA} author] }              { set SCRIPT_AUTHOR             [VALUE-GET ${SCRIPT_DATA} author] }
            if { [dict exists ${SCRIPT_DATA} documentation] }       { set SCRIPT_DOCS               [VALUE-GET ${SCRIPT_DATA} documentation] }
            if { [dict exists ${SCRIPT_DATA} giturl] }              { set SCRIPT_GITURL             [VALUE-GET ${SCRIPT_DATA} giturl] }
            if { [dict exists ${SCRIPT_DATA} gitrevision] }         { set SCRIPT_GITREVISION        [VALUE-GET ${SCRIPT_DATA} gitrevision] }
            if { [dict exists ${SCRIPT_DATA} troubleshooting] }     { set SCRIPT_TROUBLESHOOTING    [VALUE-GET ${SCRIPT_DATA} troubleshooting] }
            if { [dict exists ${SCRIPT_DATA} mineggdropversion] }   { set SCRIPT_MIN_VERS_EGG       [VALUE-GET ${SCRIPT_DATA} mineggdropversion] }
            if { [dict exists ${SCRIPT_DATA} mintclversion] }       { set SCRIPT_MIN_VERS_TCL       [VALUE-GET ${SCRIPT_DATA} mintclversion] }
            if { [dict exists ${SCRIPT_DATA} packagesrequire] }     { set SCRIPT_PKG_REQUIRE        [VALUE-GET ${SCRIPT_DATA} packagesrequire] }
            if { [dict exists ${SCRIPT_DATA} postinstalltext] }     { set SCRIPT_POST_INSTALL       [VALUE-GET ${SCRIPT_DATA} postinstalltext] }

            # Control GIT VALIDE
            if { [::TSM::FCT::Git-Validator ${SCRIPT_GITURL} ${SCRIPT_GITREVISION}] != 1 } {
                ::TSM::Show::Error "Source list '${LIST_NAME}' have bad source URI/REVISION for '${SCRIPT_NAME}' ( ${SCRIPT_GITURL} / ${SCRIPT_GITREVISION} )";
                continue
            }
            set SCRIPT_COMMIT_VERSION   [Git-COMMIT-VERSION ${SCRIPT_GITURL} ${SCRIPT_GITREVISION}]
            incr SOURCE(SCRIPT_NUMBER)
            incr SCRIPTS_CNT
            #
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCENAME ${LIST_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCEDATE ${LIST_DATE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCECONTACT ${LIST_CONTACT}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODENAME ${SCRIPT_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODEVERS ${SCRIPT_VERSION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} COMMITVERS ${SCRIPT_COMMIT_VERSION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CATEGORY ${SCRIPT_CATEGORY}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DESCRIPTION ${SCRIPT_DESCRIPTION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} AUTHOR ${SCRIPT_AUTHOR}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DOCS ${SCRIPT_DOCS}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} GITURL ${SCRIPT_GITURL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} GITREVISION ${SCRIPT_GITREVISION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} TROUBLESHOOTING ${SCRIPT_TROUBLESHOOTING}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_EGG ${SCRIPT_MIN_VERS_EGG}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_TCL ${SCRIPT_MIN_VERS_TCL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} PKG_REQUIRE ${SCRIPT_PKG_REQUIRE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} POST_INSTALL ${SCRIPT_POST_INSTALL}
        }
    }
    dict set DBSource ${LIST_NAME} SCRIPTS_CNT ${SCRIPTS_CNT}
    puts [format "Informations list: '%s' by '%s' with '%s' scripts Last update: '%s'" ${LIST_NAME} ${LIST_CONTACT} ${SCRIPTS_CNT} ${LIST_DATE}]
    return 1
}
#########
namespace eval ::TSM::JSon {}
proc ::TSM::JSon::Valid { FILENAME JSON_DATA } {
    if { ![::json::validate ${JSON_DATA}] || [llength ${JSON_DATA}] == 0} {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an JSON FILE!"
    }
    if { [catch { ::json::json2dict ${JSON_DATA} } ERR_MSG] } {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an correct format JSON FILE! (JSON ERROR FORMAT)"
  }
    return 1
}

#########
namespace eval ::TSM::Config {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::Config::Locate:FILENAME {} {
    variable ::TSM::CONFIG
    # Chargement unique (non en cascade)
    foreach CONFIG_PATH ${CONFIG(PathList)} {
        if { [file exists "${CONFIG_PATH}/${CONFIG(FILENAME)}"] } { return "${CONFIG_PATH}/${CONFIG(FILENAME)}" }
    }
    return -code error "Config file '${CONFIG(FILENAME)}' not found. Rename 'TSM.example.cfg' to '${CONFIG(FILENAME)}' and edit it!"
}
proc ::TSM::Config::Check {} {
    variable ::TSM::CONFIG
    variable ::TSM::SOURCE
    ### sources
    if { ![dict exists ${CONFIG(DATA)} sources] } {  
        ::TSM::Show::Error "No sources list in '${CONFIG(FILENAME)}' file." 2;
    }
    ### eggdrop
    if { ![dict exists ${CONFIG(DATA)} eggdrop] } { 
        ::TSM::Show::Error "No key 'eggdrop' in '${CONFIG(FILENAME)}' file." 2;
    } else {
        ## eggdrop binary
        if { ![dict exists ${CONFIG(DATA)} eggdrop binary] } { 
            ::TSM::Show::Error "No value 'binary' for key 'eggdrop' in '${CONFIG(FILENAME)}' file." 2;
        } else {
            set eggdrop_path [file normalize [CONFIG-GET eggdrop binary]]
            if { ![file executable ${eggdrop_path}] } { ::TSM::Show::Error "Value 'binary' for key 'eggdrop' in '${CONFIG(FILENAME)}' is not executable (${eggdrop_path}) file." 2; }
            set ::TSM::EGGDROP_VERSION  [lindex [RUN-EXEC strings ${eggdrop_path} | grep EGG_STRINGVER] 1]
            set ::TSM::TCL_VERSION      [lindex [RUN-EXEC strings ${eggdrop_path} | grep TCL_VERSION] 1]
        }
        ## eggdrop installdir
        if { ![dict exists ${CONFIG(DATA)} eggdrop installdir] } { 
            ::TSM::Show::Error "No value 'installdir' for key 'eggdrop' in '${CONFIG(FILENAME)}' file." 2;
        } else {
            set ::TSM::INSTALLDIR [file normalize [CONFIG-GET eggdrop installdir]]
            if { ![file isdirectory ${::TSM::INSTALLDIR}] } { ::TSM::Show::Error "Value 'installdir' for key 'eggdrop' in '${CONFIG(FILENAME)}' is not an directory (${::TSM::INSTALLDIR}) file." 2; }
        }
    }
    ### list
    if { ![dict exists ${CONFIG(DATA)} list] } { 
        ::TSM::Show::Error "No key 'list' in '${CONFIG(FILENAME)}' file." 2;
    } else {
        ## list limit
        if { ![dict exists ${CONFIG(DATA)} list limit] } { 
            ::TSM::Show::Error "No value 'limit' for key 'list' in '${CONFIG(FILENAME)}' file." 2;
        }
    }
    ### search
    if { ![dict exists ${CONFIG(DATA)} search] } { 
        ::TSM::Show::Error "No key 'search' in '${CONFIG(FILENAME)}' file." 2;
    } else {
        ## search limit
        if { ![dict exists ${CONFIG(DATA)} search limit] } { 
            ::TSM::Show::Error "No value 'limit' for key 'search' in '${CONFIG(FILENAME)}' file." 2;
        }
    }
    ### update
    if { ![dict exists ${CONFIG(DATA)} update] } { 
        ::TSM::Show::Error "No key 'update' in '${CONFIG(FILENAME)}' file." 2;
    } else {
        ## search limit
        if { ![dict exists ${CONFIG(DATA)} update checkmethod] } { 
            ::TSM::Show::Error "No value 'checkmethod' for key 'update' in '${CONFIG(FILENAME)}' file." 2;
        } else {
            set checkmethod [VALUE-GET ${CONFIG(DATA)} update checkmethod]
            if { ! [string match "commit" $checkmethod] && ! [string match "version" $checkmethod] } {
                ::TSM::Show::Error "Possible value for 'update->checkmethod' is 'commit' or 'version' in '${CONFIG(FILENAME)}' file." 2;
            }
        }
    }
}
proc ::TSM::Config::Load {} {
    variable ::TSM::CONFIG
    if { [ catch {
        set CONFIG(FilePath) [::TSM::Config::Locate:FILENAME]
    } ERROR_MSG ] } {
        ::TSM::Show::Error "${ERROR_MSG}"
        return 
    }
    puts [format "Reading Config file from '%s'..." ${CONFIG(FilePath)}]
    File-Check-Permission ${CONFIG(FilePath)}
    set CONFIG(DATA) [File-Read-JSon2Dict ${CONFIG(FilePath)}]
}
#########
namespace eval ::TSM::COMMANDS {
    namespace import -force ::TSM::FCT::*
}
proc ::TSM::COMMANDS::UpdateDB {} {
    variable ::TSM::SOURCE
    variable ::TSM::SCRIPTS
    variable ::TSM::DBSource
    ::TSM::Source::Get:FILENAME:Path
    set SOURCE(SCRIPT_NUMBER)   0
    set SOURCE(LIST_NUMBER)     0
    foreach SOURCE_URI ${SOURCE(LIST)} {
        if { [string match http* ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA [Get-URL-JSon2Dict ${SOURCE_URI}]
            puts [format "Checking script repository from '%s'... Please be patient, it may take a while ..." ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ![::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            incr SOURCE(LIST_NUMBER)
        } elseif { [File-Check-Permission ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA    [File-Read-JSon2Dict ${SOURCE_URI}]
            puts [format "Checking script repository from '%s'... Please be patient, it may take a while ..." ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ! [::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            incr SOURCE(LIST_NUMBER)
        } else {
            ::TSM::Show::Error "The file '${SOURCE_URI}' can't read!" 0
            continue
        }
    }
    puts "--------------------"
    puts "Total lists '${SOURCE(LIST_NUMBER)}' with scripts: '${SOURCE(SCRIPT_NUMBER)}'"
    dict set DBSource DB Update At      [clock seconds]
    dict set DBSource DB Source Count   ${SOURCE(LIST_NUMBER)}
    dict set DBSource DB Script Count   ${SOURCE(SCRIPT_NUMBER)}
    File-Write ${SCRIPTS(DB)} [DICT-2-PRETTY-JSON ${DBSource}] 1 w
}

proc ::TSM::COMMANDS::GenDateNow {} {
    puts "[clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S %Z" -gmt 1]"
}
proc ::TSM::COMMANDS::List { SEARCH_TEXT } {
    ::TSM::COMMANDS::FIND ${SEARCH_TEXT} "list"
}
proc ::TSM::COMMANDS::Search { SEARCH_TEXT } {
    ::TSM::COMMANDS::FIND ${SEARCH_TEXT} "search"
}
proc ::TSM::COMMANDS::FIND { SEARCH_TEXT {TYPE "list"} } {
    variable ::TSM::DBSource
    variable ::TSM::CMDLINE
    variable ::TSM::SCRIPTS
    if { [string match -nocase "list" ${TYPE}]} {
        set TYPE "list"
        set SEARCH_IN "\${CODENAME}"
    } else {
        set TYPE "search"
        set SEARCH_IN "\${DESCRIPTION}"  
    }
    try {
        array set params [::cmdline::getoptions SEARCH_TEXT [set CMDLINE([set TYPE]_options)] [set CMDLINE([set TYPE]_usage)]]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA         [File-Read-JSon2Dict ${SCRIPTS(DB)}]
    set found           0
    set VERSION_TYPE    ${params(v)}
    if { [string match -nocase "version" ${VERSION_TYPE}] } { set S_VERSION "\${CODEVERS}" } else { set S_VERSION "\${COMMITVERS}" }
    
    puts "*--------*----------------*------------------*------------------*----------------*--------------------------------------------------------*------------*"
    puts "|   ID   |      Name      | [TEXT-SPACE-SEP "Local ${VERSION_TYPE}" 16] | [TEXT-SPACE-SEP "Source ${VERSION_TYPE}" 16] |    Category    |                      Descripstion                      |   STATUS   |"
    puts "*--------*----------------*------------------*------------------*----------------*--------------------------------------------------------*------------*"
    dict for {id info} [VALUE-GET ${DB_DATA} SCRIPTS_INDEX] {
        dict with info {
            if { 
                [string match -nocase "*${SEARCH_TEXT}*" [subst ${SEARCH_IN}]] \
                && ( [string match -nocase "all" ${params(c)}] || [string match -nocase ${params(c)} ${CATEGORY} ] )
            } {
                if { ${found} >= ${params(l)} } { break }
                set MSG     "| [TEXT-SPACE-SEP ${id} 6] "
                append MSG  "| [TEXT-SPACE-SEP ${CODENAME} 14] "
                append MSG  "| [TEXT-SPACE-SEP [SCRIPT-GET-VERSION-INSTALLED ${CODENAME} ${VERSION_TYPE}] 16] "
                append MSG  "| [TEXT-SPACE-SEP [subst ${S_VERSION}] 16] "
                append MSG  "| [TEXT-SPACE-SEP ${CATEGORY} 14] "
                append MSG  "| [TEXT-SPACE-SEP ${DESCRIPTION} 54] "
                append MSG  "| [TEXT-SPACE-SEP [SCRIPT-GET-STATUS ${CODENAME} ${CODEVERS} ${MIN_VERS_EGG} ${MIN_VERS_TCL}] 10] |"
                puts ${MSG}
                incr found
            }
        }

    }
    if { ${found} == 0 } { 
        puts "|    -   |       -        |        -         |       ALL      |                Nohting found ...                   |          ALL         |"
    }
    puts "*--------*----------------*------------------*------------------*----------------*--------*-----------------------------------------------*------------*"
    puts "| [TEXT-SPACE-SEP "Help: ${::argv0} List -help" 42] | [TEXT-SPACE-SEP "Category: ${params(c)}" 42] | [TEXT-SPACE-SEP "Limit: ${params(l)}" 58] |"
    puts "*--------------------------------------------*--------------------------------------------*------------------------------------------------------------*"
    puts "* Status legend : 'A' = Available, 'I' = Installed, 'U' = Can be Updated, 'T' = TCL version conflit, 'E' = EggDrop version conflit                     |"
    puts "* For more information on a script: [TEXT-SPACE-SEP "${::argv0} show <ID|Name>" 30]                                                                                     |"
    puts "*------------------------------------------------------------------------------------------------------------------------------------------------------*"
    
}
proc ::TSM::COMMANDS::Install { args } {
    variable ::TSM::CMDLINE
    variable ::TSM::CONFIG
    variable ::TSM::SCRIPTS
    try {
        array set params [::cmdline::getoptions args ${CMDLINE(install_options)} ${CMDLINE(install_usage)}]
    } trap {CMDLINE USAGE} {msg o} {
        puts ${msg}
	    exit 1
    }
    set DB_DATA         [File-Read-JSon2Dict ${SCRIPTS(DB)}]
    set SCRIPT_ID       [SCRIPT-GET-ID ${args}]
    set SCRIPT_DATA     [SCRIPT-GET-VALUE ${SCRIPT_ID}]
    set SCRIPT_NAME     [VALUE-GET ${SCRIPT_DATA} CODENAME]
    set SCRIPT_VERS     [VALUE-GET ${SCRIPT_DATA} CODEVERS]
    set SCRIPT_GITURL   [VALUE-GET ${SCRIPT_DATA} GITURL]
    set INSTALLDIR      [file normalize [CONFIG-GET eggdrop installdir]]
    if { ! [file exists ${INSTALLDIR}] } {
        puts "The directory '${INSTALLDIR}' don't exist! : Create the directory or change the INSTALLDIR in ${CONFIG(FILENAME)}";
        exit 2
    }
    RUN-IN-PATH ${INSTALLDIR} {
        if { [file isdirectory ${SCRIPT_NAME}] } {
            puts "The directory '${INSTALLDIR}/${SCRIPT_NAME}' already exists!"
            puts "Remove it or use ${::argv0} update ${SCRIPT_NAME} !";
            exit 2
        }
        puts "Get script source from '${SCRIPT_GITURL}' into '${INSTALLDIR}/${SCRIPT_NAME}'."
        RUN-EXEC git clone ${SCRIPT_GITURL} ${SCRIPT_NAME}
        RUN-IN-PATH ${SCRIPT_NAME} {
            RUN-EXEC git fetch ${SCRIPT_GITURL} [VALUE-GET ${SCRIPT_DATA} GITREVISION]
            RUN-EXEC git checkout [VALUE-GET ${SCRIPT_DATA} GITREVISION]
            set commit [RUN-EXEC git rev-parse HEAD]
            File-Write git-commit ${commit}
        }
        # write in script dir info
        File-Write .TSM "${SCRIPT_NAME} ${commit}"

    }
    puts "Commit: ${commit}"
    # write in catalogue script info
    File-Write "${SCRIPTS(RUN_IN_PATH)}/.TSM" "${SCRIPT_NAME} ${commit} ${SCRIPT_VERS} ${INSTALLDIR}/${SCRIPT_NAME}" 0 "a+"

}    
proc ::TSM::COMMANDS::Show { STR_SEARCH } {
    variable ::TSM::DBSource
    variable ::TSM::SCRIPTS
    set DB_DATA [File-Read-JSon2Dict ${SCRIPTS(DB)}]
    set found 1
    if { [string is entier ${STR_SEARCH}] && ![dict exists ${DB_DATA} SCRIPTS_INDEX ${STR_SEARCH}] } {
        ::TSM::Show::Error "${::argv0} Show: script ID '${STR_SEARCH}' no found" 2
    } elseif { ![string is entier ${STR_SEARCH}] } {
        set found 0
        dict for {id info} [VALUE-GET ${DB_DATA} SCRIPTS_INDEX] {
            dict with info {
                if { [string match -nocase ${STR_SEARCH} ${CODENAME}] } {
                    set STR_SEARCH ${id}
                    set found 1
                    break
                }
            }
        }
    }
    if { ! ${found} } {
        ::TSM::Show::Error "${::argv0} Show: script Name '${STR_SEARCH}' no found" 2
    }
    set SCRIPT_DATA [VALUE-GET ${DB_DATA} SCRIPTS_INDEX ${STR_SEARCH}]
    dict with SCRIPT_DATA {
        puts ""
        puts "****** SOURCE INFORMATIONS ******"
        puts ""
        puts "[TEXT-SPACE-SEP "NAME" 30]: [VALUE-DEFAULT ${SOURCENAME}]"
        puts "[TEXT-SPACE-SEP "DATE" 30]: [VALUE-DEFAULT ${SOURCEDATE}]"
        puts "[TEXT-SPACE-SEP "CONTACT" 30]: [VALUE-DEFAULT ${SOURCECONTACT}]"
        puts ""
        puts "****** SCRIPT INFORMATIONS ******"
        puts ""
        puts "[TEXT-SPACE-SEP "ID" 30]: [VALUE-DEFAULT ${STR_SEARCH}]"
        puts "[TEXT-SPACE-SEP "NAME" 30]: [VALUE-DEFAULT ${CODENAME}]"
        puts "[TEXT-SPACE-SEP "VERSION" 30]: [VALUE-DEFAULT ${CODEVERS}]"
        puts "[TEXT-SPACE-SEP "CATEGORY" 30]: [VALUE-DEFAULT ${CATEGORY}]"
        puts "[TEXT-SPACE-SEP "DESCRIPTION" 30]: [VALUE-DEFAULT ${DESCRIPTION}]"
        puts "[TEXT-SPACE-SEP "AUTHOR" 30]: [VALUE-DEFAULT ${AUTHOR}]"
        puts "[TEXT-SPACE-SEP "GIT URL" 30]: [VALUE-DEFAULT ${GITURL}]"
        puts "[TEXT-SPACE-SEP "GIT REVISION" 30]: [VALUE-DEFAULT ${GITREVISION}]"
        puts "[TEXT-SPACE-SEP "TROUBLESHOOTING" 30]: [VALUE-DEFAULT ${TROUBLESHOOTING}]"
        puts "[TEXT-SPACE-SEP "Minimum version for Eggdrop" 30]: [VALUE-DEFAULT ${MIN_VERS_EGG}]"
        puts "[TEXT-SPACE-SEP "Minimum version for TCL" 30]: [VALUE-DEFAULT ${MIN_VERS_TCL}]"
        puts ""
        puts "****** Packages Required ******"
        puts "[VALUE-DEFAULT-REVERSE ${PKG_REQUIRE}]"
        
        dict for {PKG_NAME PKG_VERS} ${PKG_REQUIRE} {
            puts "[TEXT-SPACE-SEP "${PKG_NAME}" 30]: [VALUE-DEFAULT ${PKG_VERS}]"
        }
        puts ""
        puts "****** post-installation INFORMATIONS ******"
        puts "[VALUE-DEFAULT-REVERSE ${POST_INSTALL}]"
        foreach {INSTALL_TEXT} ${POST_INSTALL} {
            puts "      ${INSTALL_TEXT}"
        }
        puts ""
        puts "*********************************"
    }
}
#########
namespace eval ::TSM::COMMANDS::Help {}
proc ::TSM::COMMANDS::Help { args } {
    set COMMANDS    [lindex ${args} 0]
    set SUBCOMMANDS [lrange ${args} 1 end]
    switch -nocase ${COMMANDS} {
        UpdateDB  {
            ::TSM::COMMANDS::Help::UpdateDB 1
        }
        List  {
            ::TSM::COMMANDS::Help::List 1
        }
        Search  {
            ::TSM::COMMANDS::Help::Search 1
        }
        GenDateNow  {
            ::TSM::COMMANDS::Help::GenDateNow 1
        }
        Install  {
            ::TSM::COMMANDS::Help::Install 1
        }
        Show  {
            ::TSM::COMMANDS::Help::Show 1
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::COMMANDS::Help::UpdateDB    { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} UpdateDB               - Update database list of available scripts"
}
proc ::TSM::COMMANDS::Help::Search    { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Search <search_string> - Search in scripts descriptions"
    if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(search_options)} ${::TSM::CMDLINE(search_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::List        { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} List   <search_string> - List scripts based on script names"
    if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(list_options)} ${::TSM::CMDLINE(list_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::Main  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} help       <parameter> - Show help for <parameter>"
}
proc ::TSM::COMMANDS::Help::Install  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Install     <Num|Name> - Install script"
       if { ${FULL_DESCRIPTION} } {
        puts ""
        puts [::cmdline::usage ${::TSM::CMDLINE(install_options)} ${::TSM::CMDLINE(install_usage)}]
    }
}
proc ::TSM::COMMANDS::Help::GenDateNow  { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} GenDateNow             - Generator date now with format '%a, %d %b %Y %H:%M:%S %Z'"
}
proc ::TSM::COMMANDS::Help::Show        { { FULL_DESCRIPTION 0 } } {
    puts "${::argv0} Show        <Num|Name> - Show script details"
}
#########

proc ::TSM::main { } {
    variable ::TSM::SOURCE
    ::TSM::Init
    set COMMANDS    [lindex ${::argv} 0]
    set SUBCOMMANDS [lrange ${::argv} 1 end]
    switch -nocase ${COMMANDS} {
        UpdateDB  {
            ::TSM::COMMANDS::UpdateDB
        }
        List  {
            ::TSM::COMMANDS::List ${SUBCOMMANDS}
        }
        GenDateNow  {
            ::TSM::COMMANDS::GenDateNow
        }
        Show  {
            ::TSM::COMMANDS::Show ${SUBCOMMANDS}
        }
        Search  {
            ::TSM::COMMANDS::Search ${SUBCOMMANDS}
        }
        Install  {
            ::TSM::COMMANDS::Install ${SUBCOMMANDS}
        }
        Help  {
            ::TSM::COMMANDS::Help ${SUBCOMMANDS}
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::Init {} {
    namespace import -force ::TSM::FCT::*
    PKG-Load Tcl 8.5
    PKG-Load json
    PKG-Load json::write
    PKG-Load http
    PKG-Load tls
    PKG-Load cmdline 1.5
    
    ::TSM::Config::Load
    ::TSM::Config::Check
    ::TSM::Show::Banner
    ::TSM::Show::Informations

    variable ::TSM::CMDLINE
    set CMDLINE(list_options)       [list  \
                                        [list l.arg [CONFIG-GET list limit]         "set the limit to show"]                \
                                        [list c.arg "all"                           "set category to find"]                 \
                                        [list v.arg [CONFIG-GET update checkmethod] "set method version"]                   \
                                    ]
    set CMDLINE(list_usage)         "List \[options] <search_string> ...\noptions:"

    set CMDLINE(search_options)     [list  \
                                        [list l.arg [CONFIG-GET search limit]       "set the limit to show"]                \
                                        [list c.arg "all"                           "set category to find"]                 \
                                        [list v.arg [CONFIG-GET update checkmethod] "set method check (version|commit)"]    \
                                    ]
    set CMDLINE(search_usage)       "Search \[options] <search_string> ...\noptions:"

    set CMDLINE(install_options)    [list  \
                                        [list installdir.arg  ${::TSM::INSTALLDIR}    "set the installdir"] \
                                    ]
    set CMDLINE(install_usage)      "Install \[options] <script_name> ...\noptions:"
  
}
::TSM::main
