#!/usr/bin/env tclsh
###############################################################################################
#
#	Name		:
#		TSM (TCL-SCRIPT-MANAGER)
#
#	Description	:
#		TSM (TCL-SCRIPT-MANAGER) is a TCL script manager that allows you to easily install, update and uninstall TCL scripts.
#
#		TSM (TCL-SCRIPT-MANAGER) est un gestionnaire de scripts TCL qui vous permet d'installer, de mettre à jour et de désinstaller facilement des scripts TCL.
#
#	Donation	:
#		https://github.com/MalaGaM/DONATE
#
#	Website		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER
#
#	Support		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/issues
#
#	Docs		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/wiki
#
###############################################################################################
namespace eval ::TSM {
    variable ::TSM::DBSource [dict create]
    variable SCRIPTS
    array set SCRIPTS {
        NAME    "TSM"
        LNAME   "TCL-SCRIPT-MANAGER"
        VERSION "0.0.1"
    }
    variable ::TSM::CONFIG
    array set CONFIG {
        FILENAME    "TSM.cfg"
        
    }
    set CONFIG(PathList)    [list           \
                                [pwd]       \
                                [glob ~]    \
                                "/etc/tsm"  \
                                "/usr/etc"  \
                            ];
    variable ::TSM::SOURCE
    set SOURCE(PathList)    [list               \
                                [pwd]           \
                                [glob ~]        \
                                "/etc/tsm"      \
                                "/usr/etc/tsm" 
                            ];
}
namespace eval ::TSM::Show {}
proc ::TSM::Show::Banner {} {
    puts "  _____ ___ __  __ \n |_   _/ __|  \\/  |\n   | | \\__ \\ |\\/| |\n   |_| |___/_|  |_|\n-TCL-SCRIPT-MANAGER-"
}
proc ::TSM::Show::Help {} {
    puts "This script expects a parameter. Use:"
    puts "${::argv0} UpdateDB           - update database list of available scripts"
    puts "${::argv0} List               - list scripts based on package names"
    #puts "${::argv0} Search            - search in scripts descriptions"
    puts "${::argv0} Show <num>         - show script details"
    #puts "${::argv0} Install <num>     - install script"
    puts "${::argv0} GenDateNow         - Generator date now with format '%a, %d %b %Y %H:%M:%S %Z'"
    puts "${::argv0} help <parameter>   - Show help for <parameter>"
}
proc ::TSM::Show::Error { ERR_MSG {exit 0} } {
    puts "ERROR: ${ERR_MSG}"
    if { ${exit} != 0 } { exit ${exit} }
 
}

namespace eval ::TSM::Source {}
proc ::TSM::Source::Get:FILENAME:Path {} {
    variable ::TSM::SOURCE
    variable ::TSM::CONFIG
    # Chargement en cascade
    set SOURCE_LIST [list]
    foreach SOURCE_PATH ${SOURCE(PathList)} {
        set SOURCE_PATH [file normalize $SOURCE_PATH]
        if { [file exists "${SOURCE_PATH}/sources.list"] && [::TSM::File::Check:Perms "${SOURCE_PATH}/sources.list"] } {
            lappend SOURCE_LIST "${SOURCE_PATH}/sources.list"
        }
        if { [file isdirectory "${SOURCE_PATH}/sources.list.d"] } {
            foreach SOURCE_PATH_DIR "${SOURCE_PATH}/sources.list.d" { 
                foreach SOURCE_PATH_LIST [glob -nocomplain -directory ${SOURCE_PATH_DIR} *.list] { 
                    if { [file exists ${SOURCE_PATH_LIST}] } { lappend SOURCE_LIST ${SOURCE_PATH_LIST} }
                }
            }
        }
    }
    foreach SOURCE_FILE [dict get ${CONFIG(DATA)} sources] {
        if { [string match http* $SOURCE_FILE] } {
            lappend SOURCE_LIST ${SOURCE_FILE}
        } else {
            lappend SOURCE_LIST [file normalize ${SOURCE_FILE}]
        }
    }
    set SOURCE(LIST) [lsort -unique ${SOURCE_LIST}]
}
namespace eval ::TSM::List {}
proc ::TSM::List::Validator { SOURCE_LIST_DATA SOURCE_URI } {
    if { ![dict exists ${SOURCE_LIST_DATA} list] } { 
        ::TSM::Show::Error "Bad Source List file : No 'list' information in ${SOURCE_URI}" 0
        return 0
    }
    if { ![dict exists ${SOURCE_LIST_DATA} scripts] } { 
        ::TSM::Show::Error "Bad Source List file : No 'scripts' information in ${SOURCE_URI}" 0
        return 0
    }
    return 1
}
proc ::TSM::List::Read {} {
    variable ::TSM::SOURCE
    set SOURCE(SCRIPT_NUMBER)   0
    set SOURCE(LIST_NUMBER)     0
    foreach SOURCE_URI ${SOURCE(LIST)} {
        puts [format "Reading Source file from '%s'..." ${SOURCE_URI}]
        if { [string match http* ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA [::TSM::URL::Read:json2dict ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ![::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            incr SOURCE(LIST_NUMBER)
        } elseif { [::TSM::File::Check:Perms ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA    [::TSM::File::Read:json2dict ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] || ! [::TSM::List::Get:Informations ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            
            incr SOURCE(LIST_NUMBER)
        } else {
            ::TSM::Show::Error "::TSM::List::Read ERROR: The file '${SOURCE_URI}' can't read!" 0
            continue
        }
    }
    puts "Total lists '${SOURCE(LIST_NUMBER)}' withs scripts: '${SOURCE(SCRIPT_NUMBER)}'"
    ::TSM::DBSource::save ${::TSM::SCRIPTS(NAME)}.db

}
proc ::TSM::List::Get:Informations { LIST_DATA SOURCE_URI } {
    variable ::TSM::SOURCE
    variable ::TSM::DBSource
    set LIST_NAME       ""
    set LIST_CONTACT    ""
    set LIST_DATE       ""
    set SCRIPTS_CNT     0
    if { [dict exists ${LIST_DATA} scripts] && [dict get ${LIST_DATA} scripts] == "" } { ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: No scripts informations found in ${SOURCE_URI}. skipped!"; return 0 }
    if { [dict exists ${LIST_DATA} list] } { 
        set list    [dict get ${LIST_DATA} list]
        if { [dict exists ${list} name] }       { 
            set LIST_NAME [dict get ${list} name] 
            if { [::TSM::DBSource::exists ${LIST_NAME}] } {
                ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: Duplicata source '${SOURCE_URI}' with '[::TSM::DBSource::get_data ${LIST_NAME} source]', skipped!"; return 0
            }
        }
        if { [dict exists ${list} contact] }    { set LIST_CONTACT [dict get ${list} contact] }
        if { [dict exists ${list} updateat] }   { set LIST_DATE [dict get ${list} updateat] }
        
            dict set DBSource ${LIST_NAME} updateat ${LIST_DATE}
            dict set DBSource ${LIST_NAME} contact ${LIST_CONTACT}
            dict set DBSource ${LIST_NAME} source ${SOURCE_URI}
    } else { ::TSM::Show::Error "::TSM::List::Get:Informations ERROR: No List informations found in ${SOURCE_URI}"; return 0 }
    if { [dict exists ${LIST_DATA} scripts] } { 
        set SCRIPTS_LIST            [dict get ${LIST_DATA} scripts]
        foreach SCRIPT_DATA ${SCRIPTS_LIST} { 
            set SCRIPT_NAME             ""
            set SCRIPT_SECTION          ""
            set SCRIPT_DESCRIPTION      ""
            set SCRIPT_VERSION          ""
            set SCRIPT_AUTHOR           ""
            set SCRIPT_DOCS             null
            set SCRIPT_URL              ""
            set SCRIPT_TROUBLESHOOTING  null
            set SCRIPT_MIN_VERS_EGG     null
            set SCRIPT_MIN_VERS_TCL     null
            set SCRIPT_PKG_REQUIRE      null
            set SCRIPT_POST_INSTALL     null
            if { [dict exists ${SCRIPT_DATA} name] }                { set SCRIPT_NAME               [dict get ${SCRIPT_DATA} name] }
            if { ${SCRIPT_NAME} == "" } { continue }
            if { [dict exists ${SCRIPT_DATA} section] }             { set SCRIPT_SECTION            [dict get ${SCRIPT_DATA} section] }
            if { [dict exists ${SCRIPT_DATA} description] }         { set SCRIPT_DESCRIPTION        [dict get ${SCRIPT_DATA} description] }
            if { [dict exists ${SCRIPT_DATA} version] }             { set SCRIPT_VERSION            [dict get ${SCRIPT_DATA} version] }
            if { [dict exists ${SCRIPT_DATA} author] }              { set SCRIPT_AUTHOR             [dict get ${SCRIPT_DATA} author] }
            if { [dict exists ${SCRIPT_DATA} documentation] }       { set SCRIPT_DOCS               [dict get ${SCRIPT_DATA} documentation] }
            if { [dict exists ${SCRIPT_DATA} source] }              { set SCRIPT_URL                [dict get ${SCRIPT_DATA} source] }
            if { [dict exists ${SCRIPT_DATA} troubleshooting] }     { set SCRIPT_TROUBLESHOOTING    [dict get ${SCRIPT_DATA} troubleshooting] }
            if { [dict exists ${SCRIPT_DATA} mineggdropversion] }   { set SCRIPT_MIN_VERS_EGG       [dict get ${SCRIPT_DATA} mineggdropversion] }
            if { [dict exists ${SCRIPT_DATA} mintclversion] }       { set SCRIPT_MIN_VERS_TCL       [dict get ${SCRIPT_DATA} mintclversion] }
            if { [dict exists ${SCRIPT_DATA} packagesrequire] }     { set SCRIPT_PKG_REQUIRE        [dict get ${SCRIPT_DATA} packagesrequire] }
            if { [dict exists ${SCRIPT_DATA} postinstalltext] }     { set SCRIPT_POST_INSTALL       [dict get ${SCRIPT_DATA} postinstalltext] }
            incr SOURCE(SCRIPT_NUMBER)
            incr SCRIPTS_CNT
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCENAME ${LIST_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCEDATE ${LIST_DATE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} SOURCECONTACT ${LIST_CONTACT}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODENAME ${SCRIPT_NAME}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CODEVERS ${SCRIPT_VERSION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} CATEGORY ${SCRIPT_SECTION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DESCRIPTION ${SCRIPT_DESCRIPTION}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} AUTHOR ${SCRIPT_AUTHOR}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} DOCS ${SCRIPT_DOCS}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} URL ${SCRIPT_URL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} TROUBLESHOOTING ${SCRIPT_TROUBLESHOOTING}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_EGG ${SCRIPT_MIN_VERS_EGG}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} MIN_VERS_TCL ${SCRIPT_MIN_VERS_TCL}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} PKG_REQUIRE ${SCRIPT_PKG_REQUIRE}
            dict set DBSource SCRIPTS_INDEX ${SCRIPTS_CNT} POST_INSTALL ${SCRIPT_POST_INSTALL}
        }
    }
    dict set DBSource ${LIST_NAME} SCRIPTS_CNT ${SCRIPTS_CNT}
    puts [format "Informations list: '%s' by '%s' with '%s' scripts Last update: '%s'" ${LIST_NAME} ${LIST_CONTACT} ${SCRIPTS_CNT} ${LIST_DATE}]
    return 1
}
namespace eval ::TSM::JSon {}
proc ::TSM::JSon::Valid { FILENAME JSON_DATA } {
    if { ![::json::validate ${JSON_DATA}] || [llength $JSON_DATA] == 0} {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an JSON FILE!"
    }
    if { [catch { ::json::json2dict ${JSON_DATA} } ERR_MSG] } {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an correct format JSON FILE! (JSON ERROR FORMAT)"
  }
    return 1
}
namespace eval ::TSM::File {}
proc ::TSM::File::Read:json2dict { FILENAME } {
    set FILE_DATA   [::TSM::File::Read:Data ${FILENAME}]
    if { [catch {
                    ::TSM::JSon::Valid ${FILENAME} ${FILE_DATA}
    } ERROR_MSG] } { 
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${FILE_DATA}];
}
proc ::TSM::File::Read:Data { FILENAME } {
    set FILE_PIPE [open ${FILENAME} r]
    set FILE_DATA [read ${FILE_PIPE}]
    close ${FILE_PIPE}
    return ${FILE_DATA}
}
proc ::TSM::File::Check:Perms { FILENAME {exit 0} } {
    if { ![file isfile ${FILENAME}] } { ::TSM::Show::Error "'${FILENAME}' is not an file." ${exit}; } 
    if { ![file readable  ${FILENAME}] } { ::TSM::Show::Error "'${FILENAME}' is not readable file. check perms" ${exit}; } 
    return 1
}
    # https://boulets.eggdrop.fr/tcl/routines/tcl-toolbox-0033.html
namespace eval ::TSM::DBSource {}
###############################################################################
### Crée une entrée dans la base de données.
###############################################################################

###############################################################################
### Supprime une catégorie et ses sous-catégories dans la base de données.
###############################################################################
proc ::TSM::DBSource::delete_entry {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } elseif { ![::tcl::dict::exists $DBSource {*}${args}] } {
        return -code error "entrée inexistante"
    } else {
        if { [catch { ::tcl::dict::unset DBSource {*}${args} }] } {
            return -code error "entrée inexistante"
        }
    }
}
###############################################################################
### Affiche les entrées que contiennent une catégorie dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_entries {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error  "base de données vide"
    } else {
        if { [catch { ::tcl::dict::keys [::tcl::dict::get $DBSource {*}${args}] } result ] } {
            return -code error "catégorie inexistante"
        } else {
            return $result
        }
    }
}
###############################################################################
### Affiche la valeur d'une entrée dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_data {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } else {
        if { [catch { ::tcl::dict::get $DBSource {*}${args} } result] } {
            return -code error "catégorie inexistante"
        } else {
            return $result
        }
    }
}
proc ::TSM::DBSource::exists {args} {
    variable ::TSM::DBSource
    if { ![::tcl::info::exists DBSource] } {
        return 0
    } else {
        if { [catch { ::tcl::dict::get $DBSource {*}${args} } result] } {
            return 0
        } else {
            return 1
        }
    }
}
proc ::TSM::DBSource::save { DB_FILE } {
    variable ::TSM::DBSource
    set FILE_PIPE       [open ${DB_FILE} w];
    fconfigure ${FILE_PIPE} -translation binary;
    puts -nonewline ${FILE_PIPE} ${DBSource}
    close ${FILE_PIPE}
}
proc ::TSM::DBSource::restore { DB_FILE } {
    variable ::TSM::DBSource
    set FILE_PIPE   [open ${DB_FILE} r];
    set FILE_DATA   [gets ${FILE_PIPE}];
    set DBSource    [dict get ${FILE_DATA}]
    
    close ${FILE_PIPE}
    return $DBSource
}
###############################################################################
### Incrémente une entrée numérique dans la base de données.
### L'incrément peut être une valeur négative et/ou décimale.
###############################################################################
proc ::TSM::DBSource::incr_value {args} {
    if { ![::tcl::string::is double [set increment [lindex ${args} end]]] } {
        return -code error "l'incrément doit être numérique"
    } else {
        set args [lreplace ${args} end end]
        variable ::TSM::DBSource
        if { ![::tcl::info::exists DBSource] } {
            return -code error "base de données vide"
        } else {
            if { ![::tcl::dict::exists $DBSource {*}${args}] } {
                return -code error "entrée inexistante"
            } elseif { ![::tcl::string::is double [::tcl::dict::get $DBSource {*}${args}]] } {
                return -code error "la valeur de cette entrée n'est pas numérique"
            } elseif { [catch { ::tcl::dict::set DBSource {*}${args} [expr {[::tcl::dict::get $DBSource {*}${args}] + $increment}] } result] } {
                return -code error "catégorie inexistante"
            } else {
                return $result
            }
        }
    }
}
###
namespace eval ::TSM::Config {}
proc ::TSM::Config::Locate:FILENAME {} {
    variable ::TSM::CONFIG
    # Chargement unique (non en cascade)
    foreach CONFIG_PATH ${CONFIG(PathList)} {
        if { [file exists "${CONFIG_PATH}/${CONFIG(FILENAME)}"] } { return "${CONFIG_PATH}/${CONFIG(FILENAME)}" }
    }
    return -code error "Config file '${CONFIG(FILENAME)}' not found. Rename 'TSM.example.cfg' to '${CONFIG(FILENAME)}' and edit it!"
}
proc ::TSM::Config::Check {} {
    variable ::TSM::CONFIG
    variable ::TSM::SOURCE
    if { ![dict exists ${CONFIG(DATA)} sources] } { 
        ::TSM::Show::Error "No sources list in '${CONFIG(FILENAME)}' file." 2;
    }
    
}
proc ::TSM::Config::Load {} {
    variable ::TSM::CONFIG
    if { [ catch {
        set CONFIG(FilePath) [::TSM::Config::Locate:FILENAME]
    } ERROR_MSG ] } {
        puts "ERROR: ${ERROR_MSG}"
        return 
    }
    puts [format "Reading Config file from '%s'..." ${CONFIG(FilePath)}]
    ::TSM::File::Check:Perms ${CONFIG(FilePath)}
    set CONFIG(DATA) [::TSM::File::Read:json2dict ${CONFIG(FilePath)}]
}

namespace eval ::TSM::URL {}
proc ::TSM::URL::Read:json2dict { URL } {
    if { [string match https* $URL] } { ::http::register https 443 [list ::tls::socket -tls1 1 -autoservername 1] }
    if { [catch {set URL_TOKEN [::http::geturl ${URL} -binary 1]} ERR_MSG] } {
		return -code error "::TSM::URL::Read:json2dict ERROR: ${ERR_MSG} for '${URL}'."
	}
    set URL_DATA    [::http::data ${URL_TOKEN}];
    ::http::cleanup ${URL_TOKEN}
    if { [string match https* $URL] } { ::http::unregister https }
    if { [catch { 
                    ::TSM::JSon::Valid ${URL} ${URL_DATA}
    } ERROR_MSG] } {
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${URL_DATA}];
}
namespace eval ::TSM::PKG {}

proc ::TSM::PKG::Load { PKG_NAME {PKG_VERS ""} } {
    if { ${PKG_VERS} == "" && [catch { package require ${PKG_NAME} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} (${ERR})" 2
    } elseif { ${PKG_VERS} != "" && [catch { package require ${PKG_NAME} ${PKG_VERS} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} ${PKG_VERS} (${ERR})" 2
    }
}
namespace eval ::TSM::COMMANDS {}
proc ::TSM::COMMANDS::UpdateDB {} {
    ::TSM::Source::Get:FILENAME:Path
    ::TSM::List::Read
}
proc ::TSM::COMMANDS::GenDateNow {} {
    puts "[clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S %Z" -gmt 1]"
}
proc ::TSM::COMMANDS::List { SEARCH_TEXT } {
    variable ::TSM::DBSource
    set DB_DATA [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    puts "*-----------------------------------------------------------------------------------------*"
    puts "|    id    |    Name    |    version   |    CATEGORY    |    descripstion    |    repo    |"
    puts "*-----------------------------------------------------------------------------------------*"
    dict for {id info} [dict get $DB_DATA SCRIPTS_INDEX] {
        dict with info {
            if { [string match -nocase "*${SEARCH_TEXT}*" ${CODENAME}] } {
                puts "|  $id  |  $CODENAME  |  $CODEVERS  |  $CATEGORY  |  $DESCRIPTION  |  $SOURCENAME"
            }
        }
    }
    puts "*-----------------------------------------------------------------------------------------*"
}
proc ::TSM::COMMANDS::Show { num } {
    variable ::TSM::DBSource
    set DB_DATA [::TSM::DBSource::restore ${::TSM::SCRIPTS(NAME)}.db]
    if { ![dict exists $DB_DATA SCRIPTS_INDEX $num] } {
        ::TSM::Show::Error "${::argv0} Show: script id '$num' no found" 2
    }
    set SCRIPT_DATA [dict get $DB_DATA SCRIPTS_INDEX $num]
    dict with SCRIPT_DATA {
        puts "   SOURCENAME: $SOURCENAME"
        puts "   SOURCEDATE: $SOURCEDATE"
        puts "   SOURCECONTACT: $SOURCECONTACT"
        puts "   CODENAME: $CODENAME"
        puts "   CODEVERS: $CODEVERS"
        puts "   CATEGORY: $CATEGORY"
        puts "   DESCRIPTION: $DESCRIPTION"
        puts "   AUTHOR: $AUTHOR"
        puts "   URL: $URL"
        puts "   TROUBLESHOOTING: $TROUBLESHOOTING"
        puts "   MIN_VERS_EGG: $MIN_VERS_EGG"
        puts "   MIN_VERS_TCL: $MIN_VERS_TCL"
        puts "   PKG_REQUIRE: $PKG_REQUIRE"
        puts "   POST_INSTALL: $POST_INSTALL"
    }

}
proc ::TSM::COMMANDS::Help { args } {
    puts "soon $args"
}
proc ::TSM::main { } {
    variable ::TSM::SOURCE
    ::TSM::Init
    ::TSM::Show::Banner
    ::TSM::Config::Load
    ::TSM::Config::Check
    set COMMANDS [lindex ${::argv} 0]
    set SUBCOMMANDS [lrange ${::argv} 1 end]
    switch -nocase ${COMMANDS} {
        UpdateDB  {
            ::TSM::COMMANDS::UpdateDB
        }
        GenDateNow  {
            ::TSM::COMMANDS::GenDateNow
        }
        List  {
            ::TSM::COMMANDS::List ${SUBCOMMANDS}
        }
        Show  {
            ::TSM::COMMANDS::Show ${SUBCOMMANDS}
        }
        Help  {
            ::TSM::COMMANDS::Help ${SUBCOMMANDS}
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::Init {} {
    ::TSM::PKG::Load json
    ::TSM::PKG::Load http
    ::TSM::PKG::Load tls
}
::TSM::main
