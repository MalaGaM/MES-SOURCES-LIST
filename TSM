#!/usr/bin/env tclsh
###############################################################################################
#
#	Name		:
#		TSM (TCL-SCRIPT-MANAGER)
#
#	Description	:
#		TSM (TCL-SCRIPT-MANAGER) is a TCL script manager that allows you to easily install, update and uninstall TCL scripts.
#
#		TSM (TCL-SCRIPT-MANAGER) est un gestionnaire de scripts TCL qui vous permet d'installer, de mettre à jour et de désinstaller facilement des scripts TCL.
#
#	Donation	:
#		https://github.com/MalaGaM/DONATE
#
#	Website		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER
#
#	Support		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/issues
#
#	Docs		:
#		https://github.com/MalaGaM/TCL-SCRIPT-MANAGER/wiki
#
###############################################################################################
namespace eval ::TSM {
    variable SCRIPTS
    array set SCRIPTS {
        NAME    "TSM"
        LNAME   "TCL-SCRIPT-MANAGER"
        VERSION "0.0.1"
    }
    variable ::TSM::CONFIG
    array set CONFIG {
        FILENAME    "TSM.cfg"
        
    }
    set CONFIG(PathList)    [list           \
                                [pwd]       \
                                [glob ~]    \
                                "/etc/tsm"  \
                                "/usr/etc"  \
                            ];
    variable ::TSM::SOURCE
    set SOURCE(PathList)    [list               \
                                [pwd]           \
                                [glob ~]        \
                                "/etc/tsm"      \
                                "/usr/etc/tsm" 
                            ];
}
namespace eval ::TSM::Show {}
proc ::TSM::Show::Banner {} {
    puts "  _____ ___ __  __ \n |_   _/ __|  \\/  |\n   | | \\__ \\ |\\/| |\n   |_| |___/_|  |_|\n-TCL-SCRIPT-MANAGER-"
}
proc ::TSM::Show::Help {} {
    puts "This script expects a parameter. Use:"
    puts "${::argv0} update         Update source list"
}
proc ::TSM::Show::Error { ERR_MSG {exit 0} } {
    puts "ERROR: ${ERR_MSG}"
    if { ${ERR_MSG} != 0 } { exit ${exit} }
    
}

namespace eval ::TSM::Source {}
proc ::TSM::Source::Update {} {
    ::TSM::Source::Get:FILENAME:Path
    ::TSM::List::Read
}
proc ::TSM::Source::Get:FILENAME:Path {} {
    variable ::TSM::SOURCE
    variable ::TSM::CONFIG
    # Chargement en cascade
    set SOURCE_LIST [list]
    foreach SOURCE_PATH ${SOURCE(PathList)} {
        set SOURCE_PATH [file normalize $SOURCE_PATH]
        if { [file exists "${SOURCE_PATH}/sources.list"] && [::TSM::File::Check:Perms "${SOURCE_PATH}/sources.list"] } {
            lappend SOURCE_LIST "${SOURCE_PATH}/sources.list"
        }
        if { [file isdirectory "${SOURCE_PATH}/sources.list.d"] } {
            foreach SOURCE_PATH_DIR "${SOURCE_PATH}/sources.list.d" { 
                foreach SOURCE_PATH_LIST [glob -nocomplain -directory ${SOURCE_PATH_DIR} *.list] { 
                    if { [file exists ${SOURCE_PATH_LIST}] } { lappend SOURCE_LIST ${SOURCE_PATH_LIST} }
                }
            }
        }
    }
    foreach SOURCE_FILE [dict get ${CONFIG(DATA)} sources] {
        if { [string match http* $SOURCE_FILE] } {
            lappend SOURCE_LIST ${SOURCE_FILE}
        } else {
            lappend SOURCE_LIST [file normalize ${SOURCE_FILE}]
        }
    }
    set SOURCE(LIST) [lsort -unique ${SOURCE_LIST}]
}
namespace eval ::TSM::List {}
proc ::TSM::List::Validator { SOURCE_LIST_DATA SOURCE_URI } {
    if { ![dict exists ${SOURCE_LIST_DATA} list] } { 
        ::TSM::Show::Error "Bad Source List file : No 'list' information in ${SOURCE_URI}" 0
        return 0
    }
    if { ![dict exists ${SOURCE_LIST_DATA} scripts] } { 
        ::TSM::Show::Error "Bad Source List file : No 'scripts' information in ${SOURCE_URI}" 0
        return 0
    }
    return 1
}
proc ::TSM::List::Read {} {
    variable ::TSM::SOURCE
    set LIST [dict create]
    foreach SOURCE_URI ${SOURCE(LIST)} {
        puts [format "Reading Source file from '%s'..." ${SOURCE_URI}]
        if { [string match http* ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA [::TSM::URL::Read:json2dict ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            ::TSM::List::Get:Informations $SOURCE_FILE_DATA
        } elseif { [::TSM::File::Check:Perms ${SOURCE_URI}] } {
            set SOURCE_FILE_DATA    [::TSM::File::Read:json2dict ${SOURCE_URI}]
            if { ! [::TSM::List::Validator ${SOURCE_FILE_DATA} ${SOURCE_URI}] } { continue }
            ::TSM::List::Get:Informations $SOURCE_FILE_DATA
        } else {
            ::TSM::Show::Error "::TSM::List::Read ERROR: The file '${SOURCE_URI}' can't read!" 0
            continue
        }
    }
}
proc ::TSM::List::Get:Informations { LIST_DATA } {
    set LIST_NAME       ""
    set LIST_CONTACT    ""
    set LIST_DATE       ""
    set SCRIPTS_CNT     0
    if { [dict exists ${LIST_DATA} list] } { 
        set list    [dict get ${LIST_DATA} list]
        if { [dict exists ${list} name] }       { set LIST_NAME [dict get ${list} name] }
        if { [dict exists ${list} contact] }    { set LIST_CONTACT [dict get ${list} contact] }
        if { [dict exists ${list} updateat] }   { set LIST_DATE [dict get ${list} updateat] }
    }
    if { [dict exists ${LIST_DATA} scripts] } { 
        set scripts     [dict get ${LIST_DATA} scripts]
        foreach number $scripts { incr SCRIPTS_CNT }
    }
    puts [format "Informations list: '%s' by '%s' with '%s' scripts Last update: '%s'" ${LIST_NAME} ${LIST_CONTACT} ${SCRIPTS_CNT} ${LIST_DATE}]
}
namespace eval ::TSM::JSon {}
proc ::TSM::JSon::Valid { FILENAME JSON_DATA } {
    if { ![::json::validate ${JSON_DATA}] || [llength $JSON_DATA] == 0} {
        return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an JSON FILE!"
    }
    if { [catch { ::json::json2dict ${JSON_DATA} } ERR_MSG] } {
   return -code error "::TSM::JSon::Valid ERROR: The file '${FILENAME}' is not an correct format JSON FILE! (JSON ERROR FORMAT)"
  }
    return 1
}
namespace eval ::TSM::File {}
proc ::TSM::File::Read:json2dict { FILENAME } {
    set FILE_DATA   [::TSM::File::Read:Data ${FILENAME}]
    if { [catch {
                    ::TSM::JSon::Valid ${FILENAME} ${FILE_DATA}
    } ERROR_MSG] } { 
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${FILE_DATA}];
}
proc ::TSM::File::Read:Data { FILENAME } {
    set FILE_PIPE [open ${FILENAME} r]
    set FILE_DATA [read ${FILE_PIPE}]
    close ${FILE_PIPE}
    return ${FILE_DATA}
}
proc ::TSM::File::Check:Perms { FILENAME {exit 0} } {
    if { ![file isfile ${FILENAME}] } { ::TSM::Show::Error "'${FILENAME}' is not an file." ${exit}; } 
    if { ![file readable  ${FILENAME}] } { ::TSM::Show::Error "'${FILENAME}' is not readable file. check perms" ${exit}; } 
    
    return 1
}
    # https://boulets.eggdrop.fr/tcl/routines/tcl-toolbox-0033.html
namespace eval ::TSM::DBSource {}
###############################################################################
### Crée une entrée dans la base de données.
###############################################################################
proc ::TSM::DBSource::create_entry {args} {
    variable DBSource
    if { ![::tcl::info::exists DBSource] } { variable DBSource {} }
    ::tcl::dict::set DBSource {*}${args}
}
###############################################################################
### Supprime une catégorie et ses sous-catégories dans la base de données.
###############################################################################
proc ::TSM::DBSource::delete_entry {args} {
    variable DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } elseif { ![::tcl::dict::exists $DBSource {*}${args}] } {
        return -code error "entrée inexistante"
    } else {
        if { [catch { ::tcl::dict::unset DBSource {*}${args} }] } {
            return -code error "entrée inexistante"
        }
    }
}
###############################################################################
### Affiche les entrées que contiennent une catégorie dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_entries {args} {
    variable DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error  "base de données vide"
    } else {
        if { [catch { ::tcl::dict::keys [::tcl::dict::get $DBSource {*}${args}] } result ] } {
            return -code error "catégorie inexistante"
        } else {
            return $result
        }
    }
}
###############################################################################
### Affiche la valeur d'une entrée dans la base de données.
###############################################################################
proc ::TSM::DBSource::get_data {args} {
    variable DBSource
    if { ![::tcl::info::exists DBSource] } {
        return -code error "base de données vide"
    } else {
        if { [catch { ::tcl::dict::get $DBSource {*}${args} } result] } {
            return -code error "catégorie inexistante"
        } else {
            return $result
        }
    }
}
###############################################################################
### Incrémente une entrée numérique dans la base de données.
### L'incrément peut être une valeur négative et/ou décimale.
###############################################################################
proc ::TSM::DBSource::incr_value {args} {
    if { ![::tcl::string::is double [set increment [lindex ${args} end]]] } {
        return -code error "l'incrément doit être numérique"
    } else {
        set args [lreplace ${args} end end]
        variable DBSource
        if { ![::tcl::info::exists DBSource] } {
            return -code error "base de données vide"
        } else {
            if { ![::tcl::dict::exists $DBSource {*}${args}] } {
                return -code error "entrée inexistante"
            } elseif { ![::tcl::string::is double [::tcl::dict::get $DBSource {*}${args}]] } {
                return -code error "la valeur de cette entrée n'est pas numérique"
            } elseif { [catch { ::tcl::dict::set DBSource {*}${args} [expr {[::tcl::dict::get $DBSource {*}${args}] + $increment}] } result] } {
                return -code error "catégorie inexistante"
            } else {
                return $result
            }
        }
    }
}
###
namespace eval ::TSM::Config {}
proc ::TSM::Config::Locate:FILENAME {} {
    variable ::TSM::CONFIG
    # Chargement unique (non en cascade)
    foreach CONFIG_PATH ${CONFIG(PathList)} {
        if { [file exists "${CONFIG_PATH}/${CONFIG(FILENAME)}"] } { return "${CONFIG_PATH}/${CONFIG(FILENAME)}" }
    }
    return -code error "Config file '${CONFIG(FILENAME)}' not found. Rename 'TSM.example.cfg' to '${CONFIG(FILENAME)}' and edit it!"
}
proc ::TSM::Config::Check {} {
    variable ::TSM::CONFIG
    variable ::TSM::SOURCE
    #puts [dict get ${CONFIG(DATA)}]
    if { ![dict exists ${CONFIG(DATA)} sources] } { 
        ::TSM::Show::Error "No sources list in '${CONFIG(FILENAME)}' file." 2;
    }
    
}
proc ::TSM::Config::Load {} {
    variable ::TSM::CONFIG
    if { [ catch {
        set CONFIG(FilePath) [::TSM::Config::Locate:FILENAME]
    } ERROR_MSG ] } {
        puts "ERROR: ${ERROR_MSG}"
        return 
    }
    puts [format "Reading Config file from '%s'..." ${CONFIG(FilePath)}]
    ::TSM::File::Check:Perms ${CONFIG(FilePath)}
    set CONFIG(DATA) [::TSM::File::Read:json2dict ${CONFIG(FilePath)}]
}

namespace eval ::TSM::URL {}
proc ::TSM::URL::Read:json2dict { URL } {
    if { [string match https* $URL] } { ::http::register https 443 [list ::tls::socket -tls1 1 -autoservername 1] }
    if { [catch {set URL_TOKEN [::http::geturl ${URL} -binary 1]} ERR_MSG] } {
		return -code error "::TSM::URL::Read:json2dict ERROR: ${ERR_MSG} for '${URL}'."
	}
    set URL_DATA    [::http::data ${URL_TOKEN}];
    ::http::cleanup ${URL_TOKEN}
    if { [string match https* $URL] } { ::http::unregister https }
    if { [catch { 
                    ::TSM::JSon::Valid ${URL} ${URL_DATA}
    } ERROR_MSG] } {
        puts ${ERROR_MSG}; exit 1 
    }
    return [::json::json2dict ${URL_DATA}];
}
namespace eval ::TSM::PKG {}
proc ::TSM::PKG::Load { PKG_NAME {PKG_VERS ""} } {
    if { ${PKG_VERS} == "" && [catch { package require ${PKG_NAME} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} (${ERR})" 2
    } elseif { ${PKG_VERS} != "" && [catch { package require ${PKG_NAME} ${PKG_VERS} } ERR] } { 
        ::TSM::Show::Error "ERROR: ${::argv0} need package ${PKG_NAME} ${PKG_VERS} (${ERR})" 2
    }
}
proc ::TSM::main { } {
    variable ::TSM::SOURCE
    ::TSM::Init
    ::TSM::Show::Banner
    ::TSM::Config::Load
    ::TSM::Config::Check
    set COMMANDS [lindex ${::argv} 0]
    switch -nocase ${COMMANDS} {
        update  {
            ::TSM::Source::Update
        }
        default {
            ::TSM::Show::Help
        }
    }
}
proc ::TSM::Init {} {
    ::TSM::PKG::Load json 1.3
    ::TSM::PKG::Load http
    ::TSM::PKG::Load tls
}


::TSM::main
